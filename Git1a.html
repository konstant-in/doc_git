<HTML lang="ru">

<HEAD>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
    <TITLE>Git не для чайников (часть 2.1a)</TITLE>
    <meta name="KeyWords" content="git">
</HEAD>

<BODY>

    <div style="width:85%;  margin: auto;">

        <p><a href="http://htmlpreview.github.io/?https://github.com/konstant-in/doc1/blob/master/Git1.html">оригинал</a></p>

        <h3>База объектов репозитария</h3>

        <p>
            Одной из важнейших составных частей репозитария является <i>база объектов</i> - подкаталог <i>objects</i> каталога <i>.git</i>.
            <br>
            В базе объектов хранится история версий всех отслеживаемых файлов репозитория.
            Эта информация хранится в виде файлов специального формата т.н. <i>объектов (objects) Git</i>.
            <br>
            Объекты Git состоят из <i>тела</i> и <i>заголовка</i> сжатых с помощью библиотеки zlib.
            Тело объекта содержит непосредственно информацию, которую требуется сохранить, а заголовок тип этой информации (<i>тип объекта</i>) и размер тела в байтах.
            <br>
            У каждого объекта имеется уникальный <i>идентификатор (id)</i>, который вычисляется как SHA1 хеш заголовка и тела объекта.
            SHA1 хеш является 40 разрядным шестнадцатеричным числом.
            Следовательно идентификатор объекта состоит из 40 символов (цифр от <i>0</i> до <i>9</i> и букв от <i>a</i> до <i>e</i>).
            <br>
            Вычисляется хеш-функция SHA1 очень быстро.
        </p>
        <p>
            Хеш-функция - это своеобразный "отпечаток пальца" объекта. Он обладает следующими свойствами:
        </p>
        <ol>
            <li>
                Если содержимое двух объектов совпадает - то их хеши тоже совпадают.
            </li>
            <li>
                Если содержимое двух объектов различны - то их хеши тоже различны (хеш-функция SHA1 считается
                достаточно сложной для подбора или случайного возникновения коллизии).
            </li>
        </ol>

        <p>
            Использование SHA1 хеш для именования объектов позволяет быстро и однозначно идентифицировать объект, а также проверить его целостность - если объект повредился, его хеш не совпадет с именем.
            Данная функциональность встроена в Git на низком уровне и является неотъемлемой частью его философии.
            Вы не потеряете информацию во время её передачи и не получите повреждённый файл без того, чтобы Git не обнаружил это.
        </p>
        <p>
            Перед сохранением объекта в базе объектов Git отделяет первые два символа идентификатора объекта и создает поддиректорию с именем из этих двух символов в каталоге .git/objects.
            В этой поддиректории и сохраняется объект, под именем получающимся отбрасыванием первых двух символов от идентификатора объекта.
            <br>
            Например объект с идентификатором aa49df5d247524e94f09e2fe86ed6c0b96814eb0 будет хранится в каталоге .git/objects/aa, как файл с именем 49df5d247524e94f09e2fe86ed6c0b96814eb0
        </p>
        <p>
            В больших проектах объектов в базе очень много. Если бы все объекты хранились в одном каталоге, то их число могло превысить максимальное количество файлов, которое может хранится в одном каталоге или это могло бы вызвать снижения производительности (общее число объектов снижает и packs см.далее).
        </p>
        <p>
            Посмотрим все его объекты, находящиеся в каталоге <i>.git/objects</i> из нашего первого примера.
        <pre><code style="color: blue">
$ find .git/objects -type f
.git/objects/03/c1a7f12800978dde0b8cd6383595e7007d0098
.git/objects/1d/5260cb0591933230fdaaa8035a94b8e393ea20
.git/objects/27/63fac853abca428edd5c2a1b48ef5d212ff99a
.git/objects/34/4b36ba2aeb489f97a4928816eeeefb30ddfac2
.git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4
.git/objects/69/701b6e701d429882c083e98e1ecf195868b38c
.git/objects/6c/59b709d4abf607ab16a03b22db93412fe437a4
.git/objects/96/6e9a46c8df9aa3b2108864be07abe7b5d1d0f9
.git/objects/ad/2a32f77c6c6eac140b94619e332c89d1319b6b
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f
.git/objects/b8/92ad555729a5275bb9ba81158e2a708da84b11
</code></pre>
        Если посмотреть, содержимое объектов непосредственно каким нибудь редактором, то вместо содержимого поля и тела
        объекта, мы увидим мешанину нечитаемых символов. Это происходит потому, что заголовок и тело объекта перед записью
        сжимаются с помощью библиотеки zlib. Сжатие позволяет существенно уменьшить размер репозитория.

        <h3>Типы объектов</h3>

        <p>
            Объекты git бывают четырех типов: <i>blob</i>, <i>tree</i>, <i>commit</i> и <i>tag</i>.
        </p>
        <p>
            Тип любого объекта можно посмотреть командой <i>git cat-file</i> с ключем <i>-t</i>
        </p>
        <p>
            В нашем репозитарии имеется 11 следующих объектов:
        <pre><code style="color: blue">
03c1a7f12800978dde0b8cd6383595e7007d0098
1d5260cb0591933230fdaaa8035a94b8e393ea20
2763fac853abca428edd5c2a1b48ef5d212ff99a
344b36ba2aeb489f97a4928816eeeefb30ddfac2
475190118d49d9905c1a82c6fd11dab9ab602cc4
69701b6e701d429882c083e98e1ecf195868b38c
6c59b709d4abf607ab16a03b22db93412fe437a4
966e9a46c8df9aa3b2108864be07abe7b5d1d0f9
ad2a32f77c6c6eac140b94619e332c89d1319b6b
b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f
b892ad555729a5275bb9ba81158e2a708da84b11
</code></pre>
        Проверим типы всех этих объектов.
        <pre><code style="color: blue">
$ git cat-file -t 03c1
commit

$ git cat-file -t 1d52
blob

$ git cat-file -t 2763
tree

$ git cat-file -t 344b
commit

$ git cat-file -t 4751
blob

$ git cat-file -t 6970
commit

$ git cat-file -t 6c59
tree

$ git cat-file -t 966e
tree

$ git cat-file -t ad2a
blob

$ git cat-file -t b2fb
blob

$ git cat-file -t b892
tree
</code></pre>
        Итого из 11 объектов: 4 - blob, 4 - tree, 3 - commit.

        <h3>Объект типа blob</h3>

        <p>
            Объекты типа <i>blob</i> (Binary Large Object) - это основа репозитория.
            <br>
            Тела таких объектов хранят только содержимое файлов.
            Кроме содержимого файла в теле блоба, более не содержится ничего, в том числе там нет информации и о имени файла.
            <br>
            Имя файла и другая информация о файле сохраняются в объектах типа tree.
            <br>
            Это очень похоже на способ хранения информации в файловых системах Linux.
        </p>

        <p>
            Тело blob-объекта можно посмотреть командой <i>git cat-file</i>, с ключем <i>blob</i> или с ключем <i>-p</i> (с ним тип объекта определяется автоматически).
        </p>
        <p>
            Посмотрим тела всех наши блобов (содержимое всех версий файлов).
        <pre><code style="color: blue">
$ git cat-file -p 1d52
File1 v1
Second line (v2)

$ git cat-file -p 4751
File1 v1

$ git cat-file -p ad2a
File3 v1

$ git cat-file -p b2fb
File2 v1
</code></pre>

        <h3>Объекты типа tree</h3>

        <p>
            Как уже было сказано имена файлов и каталогов хранятся в объектах типа <i>дерево (tree)</i>. Имена файлов и каталогов сохраняются вместе с путями. Помимо имён файлов и каталогов в дереве хранятся типы, права доступа и идентификаторы блобов файлов и идентификаторы других деревьев включенных в данное дерево.
        </p>
        <p>
            Дерево git-а аналогично каталогу файловой системы, а blob аналогичен inode.
            Деревья образуют иерархию, аналогичную иерархии каталогов и файлов.
        </p>
        <p>
            Тело дерева хранит список записей, в котором каждая запись состоит из четырех полей:
        <ul>
            <li>
                Первое поле: шесть восьмеричных цифр.
                <ul>
                    <li>
                        Первая цифра: 1 для файлов, 0 для директорий.
                    <li>
                        Вторая цифра: 0 для обычных файлов, 2 для символических ссылок????, 4 - для директорий
                    <li>
                        Третья цифра: Всегда 0 (не используется).
                    <li>
                        Четвертая, пятая и шестая цифры: права владельца файла, права группы владельца и права остальных пользователей, записанные как комбинация цифр 4, 2 и 1 (4 - право на чтение, 2 - право на запись, 1 - право на выполнение).
                </ul>
            <li>
                Второе поле: Тип объекта, на который ссылается элемент списка. Может быть <i>blob</i> или <i>tree</i>.
            </li>
            <li>
                Третье поле: Ссылка - SHA1 хеш объекта, который однозначно определяет объект в репозитории git.
            </li>
            <li>
                Четвертое поле: Имя файла (если ссылка на <i>blob</i>) или имя директории (если ссылка на <i>tree</i>).
            </li>
        </ul>
        <p>
            Замечание: Права владельца файла, права группы владельца и права остальных пользователей используются а файловых системах UNIX и Linux. Используются ли они в операционной системе Windows?
            <br>
            Разрешены только такие права 644 или 755 для обычных файлов. И 664?
            <br>
            Итого все возможные комбинации:
            <br>
            040000: Каталог
            <br>
            100644: Обычный не исполняемый файл
            <br>
            100755: Обычный исполняемый файл
            <br>
            ??????? 100664: Обычный не исполняемый файл с правом записи для группы владельца
            <br>
            120000: Символическая ссылка
            <br>
            160000: Gitlink
        </p>
        <p>
            Объект-дерево после создания получает свой идентификатор на основе SHA1 хеша, и может быть после этого включен в другие деревья.
            Деревья строятся на основании информации содержащийся в индексе, а не фактического содержания рабочего каталога. Это важно для понимания работы git.
        </p>
        <p>
            Объекты-деревья служат для объединения blob-объектов и деревьев в <i>снимки(snapshot)</i> - иерархии, аналогичные каталогам файловой системе.
        </p>
        <p>
            Посмотреть содержимое дерева можно, командой <i>git ls-tree</i>, командой <i>cat-file</i> с ключем <i>-p</i>.
        </p>
        <p>
            Посмотрим содержимое всех деревьев нашего репозитория
        <pre><code style="color: blue">
$ git cat-file -p 2763
040000 tree 966e9a46c8df9aa3b2108864be07abe7b5d1d0f9    d
100644 blob 475190118d49d9905c1a82c6fd11dab9ab602cc4    file1
100644 blob ad2a32f77c6c6eac140b94619e332c89d1319b6b    file3

$ git cat-file -p 6c59
040000 tree 966e9a46c8df9aa3b2108864be07abe7b5d1d0f9    d
100644 blob 475190118d49d9905c1a82c6fd11dab9ab602cc4    file1

$ git cat-file -p 966e
100644 blob b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f    file2

$ git cat-file -p b892
040000 tree 966e9a46c8df9aa3b2108864be07abe7b5d1d0f9    d
100644 blob 1d5260cb0591933230fdaaa8035a94b8e393ea20    file1
100644 blob ad2a32f77c6c6eac140b94619e332c89d1319b6b    file3
</code></pre>
        <p>
            <i>Снимок (snapshot) системы</i> - это дерево вместе со всеми объектами на которые оно по цепочке ссылается.
            Любое дерево, определяет снимок всего рабочего каталога, либо какого-то его подкаталога.
        </p>
        <p>
            По четырем объектам-деревьям построим три снимка репозитория.
        </p>
        <p>
            Первый
        <pre><code style="color: blue">
6c59 ---+--&gt; 4751 (файл «file1»)
        |
        +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
        И второй
        <pre><code style="color: blue">
2763 ---+--&gt; 4751 (файл «file1»)
        |
        +--&gt; ad2a (файл «file3»)
        |
        +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
        И третий
        <pre><code style="color: blue">
b892 ---+--&gt; 1d52 (файл «file1» v2)
        |
        +--&gt; ad2a (файл «file3»)
        |
        +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
        <p>
            Рассмотрим, чем полезно, то что идентификаторы объектов (в том числе деревьев) являются хешем их содержимого.
        </p>
        <p>
            Пусть у двух объектов-деревьев одинаковые идентификаторы.
            Что это означает? Что внутренности этих деревьев совпадают!
            А так как внутренности деревьев - это ссылки на объекты, то это означает что два дерева ссылаются на одни и те же объекты. Которые в свою очередь тоже могут быть деревьями или блобами.
            Таким образом идентификатор дерева на самом деле идентифицирует не только "файлы в одной директории", но и все файлы во всех поддиректориях этой директории - одно имя для всей иерархии!
        </p>
        <p>
            Это свойство позволяет git-у очень быстро производить сравнение
            деревьев со сколь угодно сложной иерархией, уровнями вложенности и т.д.
            без чтения собственно содержимого - blob-ов или tree.

        </p>
        <p>

            При помощи Git-команды <i>git diff-tree</i> можно посмотреть разницу между двумя деревьями.
        <pre><code style="color: blue">
$ git diff-tree 6c59 2763
:000000 100644 0000000000000000000000000000000000000000 ad2a32f77c6c6eac140b94619e332c89d1319b6b A  file3

$ git diff-tree 2763 b892
:100644 100644 475190118d49d9905c1a82c6fd11dab9ab602cc4 1d5260cb0591933230fdaaa8035a94b8e393ea20 M  file1
</code></pre>
        <p>
            A - файл добавлен (added)
            <br>
            D - файл удален (deleted)
            <br>
            M - изменен (modified)
        </p>

        <h3>Объекты типа commit</h3>

        <p>
            Git не был бы системой контроля версий, если бы не позволял хранить историю изменений деревьев.
            Для хранения истории в git используются специальные объекты-коммиты (commits), ссылающиеся друг на друга.
            Если коммит B ссылается другой коммит A (A ← B), то говорят, что A для B является родителем (parent) или предком;
            а B для A - ребенком (child) или потомком.
            Коммит может иметь несколько родителей, либо не иметь ни одного.
            Стандартная ситуация - у каждого коммита один родитель.
        </p>
        <p>
            Тело объекта-коммит содержит следующую информацию:
        <pre><code style="color: blue">
   * ссылку на объект-дерево, который хранит иерархию рабочего каталога (первая строчка);
   * ссылка на родителя, если таковой есть; если родителей несколько, то каждый родитель на отдельной строчке;
   * author – это человек, внесший изменения в файлы проекта;
   * время создания изменений;
   * committer - это человек, внесший изменения в историю проекта, т.е. выполнивший команду git commit;
   * время фиксации изменений;
   * сообщение - пояснительный текст к коммиту.
</code></pre>
        <p>
            У коммита может быть ноль или более родителей. Обычно родителей нет только у одного первого коммита.
            Если в истории коммитов есть коммиты у которых более одного предка, то говорят о <i>слиянии</i> коммитов.
            Если в истории коммитов есть коммиты которые являются предками для нескольких коммитов, то говорят о <i>ветвлении</i> коммитов.
            Репозитории без ветвлений и слияний называется <i>линейными</i>.
        </p>
        Автором и коммитером обычно бывает один человек. В этом случае поля author и committer совпадают.
        <p>
            Поля author и committer и их почтовые адреса заполняются на основании переменных окружения:
        <pre><code style="color: blue">
GIT_AUTHOR_NAME
GIT_AUTHOR_EMAIL
GIT_COMMITTER_NAME
GIT_COMMITTER_EMAIL
</code></pre>
        Если эти переменные окружения не установлены, то значения берутся из локального или глобального файла конфигурации.
        <p>
            Поля время создания и фиксации изменений заполняются на основании переменных окружения:
        <pre><code style="color: blue">
GIT_AUTHOR_DATE
GIT_COMMITTER_DATE
</code></pre>
        Как правило эти переменные окружения не установлены и временем создании и фиксации изменений считается текущее
        время.
        <p>
            При помощи параметров --author=<i>имя &lt;email&gt;</i> и --date=<i>время</i> команды git commit можно переопределить поля author и время создания изменений.
        </p>
        <p>
            Наличие в объекте commit имени автора и коммитера, а также времени создания и фиксации изменений приводит к тому, что при прочих равных обстоятельствах команда <i>git commit</i> создает, в разное время или на разных компьютерах, коммиты с разными идентификаторами. В учебных примерах это не удобно, поэтому мы в примерах время будем задавать в переменных окружения командной строки:
        <pre><code style="color: blue">
$ export GIT_AUTHOR_DATE="2000-01-01 00:00:00"
$ export GIT_COMMITTER_DATE="2000-01-01 00:00:00"
</code></pre>
        А автора и коммитера в локальном файле конфигурации:
        <pre><code style="color: blue">
git config user.name "Ivan Ivanov"
git config user.email "ivan@localhost"
</code></pre>

        <p>
            Содержимое коммита можно посмотреть командой <i>cat-file</i> с ключем <i>commit</i> или с ключем <i>-p</i>.
        </p>
        <p>
            Посмотрим содержимое всех коммитов нашего репозитория
        <pre><code style="color: blue">
$ git cat-file -p 03c1
tree 2763fac853abca428edd5c2a1b48ef5d212ff99a
parent 69701b6e701d429882c083e98e1ecf195868b38c
author Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200
committer Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200

comment #2

$ git cat-file -p 344b
tree b892ad555729a5275bb9ba81158e2a708da84b11
parent 03c1a7f12800978dde0b8cd6383595e7007d0098
author Ivan Ivanov &lt;ivan@localhost&gt; 946677780 +0200
committer Ivan Ivanov &lt;ivan@localhost&gt; 946677780 +0200

comment #3

$ git cat-file -p 6970
tree 6c59b709d4abf607ab16a03b22db93412fe437a4
author Ivan Ivanov &lt;ivan@localhost&gt; 946677660 +0200
committer Ivan Ivanov &lt;ivan@localhost&gt; 946677660 +0200

comment #1
</code></pre>
        <p>
            Команда выводит всю информацию хранящуюся в коммите
        </p>
        <p>
            Стандартный log выводит немного меньше информации
        <pre><code style="color: blue">
$ git log
commit 344b36ba2aeb489f97a4928816eeeefb30ddfac2 (HEAD -> master)
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:03:00 2000 +0200

    comment #3

commit 03c1a7f12800978dde0b8cd6383595e7007d0098
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:02:00 2000 +0200

    comment #2

commit 69701b6e701d429882c083e98e1ecf195868b38c
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:01:00 2000 +0200

    comment #1
</code></pre>
        Настроем сокращенные log и дадим ему алиас hist:
        <pre><code style="color: blue">
$ git config --global alias.hist "log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short"
</code></pre>
        Посмотрим сокращенный log:
        <pre><code style="color: blue">
$ git hist
* 344b36b 2000-01-01 | comment #3 (HEAD -> master) [Ivan Ivanov]
* 03c1a7f 2000-01-01 | comment #2 [Ivan Ivanov]
* 69701b6 2000-01-01 | comment #1 [Ivan Ivanov]
</code></pre>
        Т.о. мы имеем хронологическую последовательность коммитов ссылающихся на снимки.
        <pre><code style="color: blue">
6970 (commit #1) --&gt; 6c59 ---+--&gt; 4751 (файл «file1»)
|                            |
|                            +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
↓
03c1 (commit #2) --&gt; 2763 ---+--&gt; 4751 (файл «file1»)
|                            |
|                            +--&gt; ad2a (файл «file3»)
|                            |
|                            +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
↓
344b (commit #3) --&gt; b892 ---+--&gt; 1d52 (файл «file1» v2)
                             |
                             +--&gt; ad2a (файл «file3»)
                             |
                             +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
        Последний коммит, в цепочке коммитов, называется <i>текущим</i>.


        <h4>Индекс (index)</h4>

        <p>
            Как мы уже сказали, что команда <i>git add</i> выполняет два действия: делает файл отслеживаемым и создает соответствующий этому файлу blob-объект.
            Но, что значит "сделать файл отслеживаемым"? Где хранится информация об отслеживаемых файлах?
        </p>
        <p>
            Хранится она <i>индексе</i> - файле .git/index. Индекс содержит список всех файлов, версии которые мы хотим сохранять.
        </p>

        <p>
            Команда <i>git add &lt;файл&gt;</i> сохраняет в индексе информацию об атрибутах файла (типе файла и правах доступа), идентификаторе блоб-объекта соответствующего этому файлу, имя файла вместе с относительным путем к этому файлу. (Также время создания/модификации, но это не попадает в коммит. Только для более быстрого сравнивания?????????)
        </p>
        <p>
            Содержимое индекса можно посмотреть командой git ls-files. Посмотрим, что у нас там сейчас находится:
        <pre><code style="color: blue">    $ git ls-files --stage
    100644 b45ef6fec89518d314f546fd6c3025367b721684 0       tutorial.txt

</code></pre>
        Из вывода команды видно, что в индексе присутствует единственный файл с именем tutorial.txt с атрибутами 100644 и
        что содержимое этого файла можно извлечь из blob-объекта с идентификатором b45ef6fec89518d314f546fd6c3025367b721684.

        <p>
            Если в рабочую папку git положить любое количество файлов с абсолютно одинаковым содержимым, и для каждого выполнить команду <i>git add</i> то, из-за того что blob-объекты не содержат никакой информации об именах файлов, всем им будет соответствовать один blob-объект, который <b>не будет</b> перезаписываться.
            <br>
            Это уменьшает размеры репозиториев хранящих большое количество одинаковых файлов.
        </p>

        <pre><code style="color: blue">
   $ cp tutorial.txt tutorial2.txt

   $ git add tutorial2.txt
   warning: LF will be replaced by CRLF in tutorial2.txt.
   The file will have its original line endings in your working directory

   $ cp tutorial.txt tutorial3.txt

   $ git add tutorial3.txt
   warning: LF will be replaced by CRLF in tutorial3.txt.
   The file will have its original line endings in your working directory

   $ find .git/objects -type f
   .git/objects/b4/5ef6fec89518d314f546fd6c3025367b721684

   $ git ls-files --stage
   100644 b45ef6fec89518d314f546fd6c3025367b721684 0       tutorial.txt
   100644 b45ef6fec89518d314f546fd6c3025367b721684 0       tutorial2.txt
   100644 b45ef6fec89518d314f546fd6c3025367b721684 0       tutorial3.txt
</code></pre>
        <p>
            Из вывода последней команды видно, что git в данный момент отслеживает состояние трех файлов: tutorial1.txt, tutorial2.txt и tutorial3.txt, и что содержимое всех этих файлов одинаковое, т.к. всем трем файлам соответствует один и тотже blob-объект.
        </p>

        <h4>Утилита gzip</h4>

        <p>
            Если нам, для каких либо целей, захочется посмотреть содержимое объектов не используя утилиты git, то это можно сделать при помощи утилиты gzip. Она реализует тот же алгоритм сжатия, что и библиотека zlib.
            Но поскольку утилита gzip не только сжимает файл, но и добавляет в его начало заголовок "\x1f\x8b\x08\x00\x00\x00\x00\x00", которого нет в объектах git, то , перед распаковкой объекта утилитой gzip, заголовок надо добавить искуственно.
        </p>
        <p>
            Чтобы распаковать blob-объект b45ef6fec89518d314f546fd6c3025367b721684, выполним:

        <pre><code style="color: blue">
   $ echo -en "\x1f\x8b\x08\x00\x00\x00\x00\x00" |cat - .git/objects/b4/5ef6fec89518d314f546fd6c3025367b721684 |gzip -dc
   blob 13Hello, World!
   gzip: stdin: unexpected end of file
</code></pre>
        Мы видим заголовок и тело объекта вместе.

    </div>
</BODY>

</HTML>
