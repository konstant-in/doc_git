<HTML lang="ru">

<HEAD>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
    <TITLE>Удаленные репозитории</TITLE>
    <meta name="KeyWords" content="git">
</HEAD>

<BODY>

    <div style="width:85%;  margin: auto;">

        <h3>Удаленные репозитории</h3>

        <p>
            Git позволяет работая в одном репозитории получать и принимать изменения из другого репозитория.
            В этом случае первый репозиторий называется <i>локальным</i>, а второй - <i>удаленным</i>.
        </p>
        <p>
            Удаленный репозиторий может располагаться на том же компьютере, что и локальный, в локальной сети, или где то в интернете. Главное у пользователя должен быть доступ к нему одним из способов, который поддерживает <i>git</i>.
            Для получения изменений достаточно иметь доступ на чтение, для передачи изменений нужен доступ на запись.
        </p>
        <p>
            Вначале надо <i>подсоединить</i> удаленный репозиторий к локальному, т.е. указать указать где он находится, при помощи <i>URL</i> и присвоить ему <i>имя (shortname)</i>.
            <br>
            Подсоединение выполняется командой <i>git remote add &lt;shortname&gt; &lt;url&gt;</i>.
            <br>
            (??? Подсоединение удаленного репозитория выполняется автоматически при его клонировании (см. далее). ???)
        </p>
        <p>
            Информация о подсоединенных репозиториях хранится в локальном конфигурационном файле репозитория.
        </p>
        <p>
            Пусть у нас имеется репозиторий в текущей папке и репозиторий по пути <i>/home/Thomas/project1</i>, с которым мы хотим работать как с удаленным репозиторием. Так команда
        <pre><code>$ git remote add origin /home/Thomas/project1</code></pre>
        подсоединяет удаленный репозиторий <i>/home/Thomas/project1</i> и назначает ему имя <i>origin</i>.
        Информация об этом сохраняется в разделе [remote "origin"] локального конфигурационного файла.
        <pre><code>[remote "origin"]
	url = /home/Thomas/project1
	fetch = +refs/heads/*:refs/remotes/origin/*</code></pre>
        <p>
            Командой <i>git remote</i> без параметров можно посмотреть список всех подсоединенных удаленных репозиториев.
            <br>
            Эта же команда с параметром «-v» выводит дополнительно URL удаленных репозиториев.
        </p>
        <p>
            Например:
        <pre><code>$ git remote
origin

$ git remote -v
origin	/home/Thomas/project1 (fetch)
origin	/home/Thomas/project1 (push)</code></pre>
        <p>
            Команда <i>git remote add</i> с дополнительными параметрами может установить разные URL для чтения (fetch) и записи (push).
        </p>

        <h3>Работа с удаленными репозиториями по сети</h3>

        <p>
            Git работает с удаленными репозиториями по локальным сетям точно также, как с репозиториями на вашем компьютере.
            У вас должна быть права на чтение и запись в папку .git репозитория.
            Кроме того работать с удаленными репозиториями можно по протоколам: HTTP/HTTPS, SSH (Secure Shell) и Git.
            Сетевого протокола протокол выбирается на основании URL.
        </p>
        <p>
            URL (Uniform Resource Locator, унифицированный указатель ресурса) — система унифицированных адресов электронных ресурсов, или единообразный определитель местонахождения ресурса (например файла).
        </p>
        <p>
            Структура URL:
            <br>
            <i>&lt;схема&gt;</i>:[//[<i>&lt;логин&gt;</i>[:<i>&lt;пароль&gt;</i>]@]<i>&lt;хост&gt;</i>[:<i>&lt;порт&gt;</i>]][/<i>&lt;URL-путь&gt;</i>]
            <br>
            где:
            <br>
            <i>схема</i> - схема обращения к ресурсу; в большинстве случаев имеется в виду сетевой протокол
            <br>
            <i>логин</i> - имя пользователя, используемое для доступа к ресурсу
            <br>
            <i>пароль</i> - пароль указанного пользователя
            <br>
            <i>хост</i> - полностью прописанное доменное имя хоста в системе DNS или IP-адрес хоста в форме четырёх групп десятичных чисел, <br>
            разделённых точками; числа — целые в интервале от 0 до 255.
            <br>
            <i>порт</i> - порт хоста для подключения
            <br>
            <i>URL-путь</i> - уточняющая информация о месте нахождения ресурса; зависит от протокола.
        </p>

        <h3>Голые репозитории</h3>

        <p>
            Помимо <i>обычных</i> репозиториев, с которыми мы до сих пор имели дело, бывают т.н. <i>голые (чистые, bare)</i> репозитории.
            Голые репозитории не имеют своего рабочего каталога.
            Они используются только в качестве удаленных репозиториев для обмена изменениями между обычными репозиториями.
        </p>
        <p>
            Такие репозитории создаются командой <i>git init</i> с параметром <i>--bare</i>.
            Имя каталога голого репозитория указывается при создании и может быть любым, но принято чтобы оно заканчивалось на «.git».
        <pre><code>
$ git init --bare test.git -b master
</code></pre>

        <h3>Создание клонов репозитория. Команда <i>git clone</i></h3>

        <p>
            Существующий репозиторий можно склонировать командой <i>git clone</i>.
            Тип клонируемого репозитория может быть любым - обычным или голым.
            Тип у клона может не совпадать с исходным.
            Голый репозиторий создается командой <i>git clone</i> с опцией <i>--bare</i>, по умолчанию - обычный репозиторий.
        </p>
        <p>
            При клонировании репозитория происходит почти точное копирование существующего репозитория (чем отличаются см. ...).
            Если клон является обычным репозиторием, то клонируемый репозиторий подсоединяется к клону как удаленный, с именем «origin».
        </p>
        <p>
            При клонировании копируется указатель текущей ветки и он становится указателем текущей веткой репозитория-клона.
            Автоматически эта ветка становится отслеживающей соответствующую удаленную ветку (что это значит см. долее).
        </p>
        <p>
            Обычно репозитории клонируют с текущей веткой <i>master</i>.
        </p>
        <p>
        <pre><code>$ git clone /home/Thomas/project1 pr1_c

$ cd pr1_c

$ git remote
origin

$ git remote -v
origin	/home/Thomas/project1 (fetch)
origin	/home/Thomas/project1 (push)</code></pre>

        <h3>Получение изменений из удаленного репозитория. Команда <i>git fetch</i></h3>

        <p>
            Команда <i>git fetch</i> загрузит с сервера все изменения, которых у вас еще нет.
            <br>
            Все новые объекты загружаются в локальную базу объектов <i>.git/objects</i>.
            <br>
            Каталог <i>.git/refs/remotes/&lt;имя_удаленного_репозитория&gt;</i> приводится в соответствие с каталогом <i>.git/refs/</i> удаленного репозитория. ????*************
        </p>
        <p>
            Указатели удаленного репозитория сокращенно называются <i>удаленными указателями</i>.
            Их имена, в локальном репозитории, состоят из имени удаленного репозитория и имени, которое они имеют в удаленном репозитории, разделенных косой чертой.
            Например указатель <i>master</i> удаленного репозитория <i>origin</i> в локальном репозитории имеет имя <i>origin/master</i>.
        </p>
        <p>
            Обратите внимание на то, что локальные и удаленные указатели ведут себя по разному.
            Если локальные указатели двигаются когда мы делаем коммиты в локальном репозитории, то удаленные указатели двигаются, когда мы получаем изменения из удаленного репозитория.
        </p>
        <p>
            Команда <i>git fetch</i> не меняет содержимого вашего рабочего каталога!
        </p>
        <p>
            После получения изменений из удаленного репозитория можно выполнить слияние командой <i>git merge</i> и
            привести файлы вашего рабочего каталога в соответствие с полученными изменениями.
        </p>

        <p>
            Получим обновлений из удаленного репозитория <i>origin</i>. Для этого выполним команду
        <pre><code>$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -&gt; origin/serverfix</code></pre>
        Вывод команды показывает, что из удаленного репозитория мы получили 7 новых (для нас) объектов и новый (для нас) указатель <i>serverfix</i>, ставший у нас удалённым указатель <i>origin/serverfix</i>.
        При этом локальный указатель на ветку <i>serverfix</i> создан не был!
        <p>
            Все удаленные указатели можно посмотреть командой <i>git branch</i> с опцией <i>-r</i>
        <pre><code>$ git branch -r
  origin/master
  origin/serverfix</code></pre>
        <p>
            Вы можите временно переключится на удаленную ветку, чтобы посмотреть новые файлы рабочего каталога (работать в удаленной ветке не получиться)
        <pre><code>$ git checkout origin/serverfix</code></pre>
        или слить удаленную ветку со своей текущей веткой
        <pre><code>git merge origin/serverfix</code></pre>

        <h3>Отслеживание веток</h3>

        <p>
            Чуть позже мы будем изучать команды работающие с удаленными репозиториями и использующие т.н. <i>отслеживаемые ветки (upstream branches)</i>.
            Отслеживаемая ветка - это ветка удаленного репозитория, которая определенным образом связана с локальной веткой.
            Отслеживаемых веток может быть сколько угодно и они могут быть из разных удаленных репозиториев.
        </p>
        <p>
            Создать локальную ветку, с тем же идентификатором как у удаленной ветки, и одновременно сделать, чтобы она отслеживала эту удаленную ветку, можно командой <i>git branch &lt;ветка1&gt; &lt;удалённый_репозиторирий&gt;/&lt;ветка2&gt;</i>.
        </p>
        <p>
            Например команда
        <pre><code>$ git branch fix origin/serverfix
Branch 'fix' set up to track remote branch 'serverfix' from origin.</code></pre>
        создает ветку <i>fix</i> и назначает ей ветку <i>origin/serverfix</i> как отслеживаемую.
        После создания указателя <i>fix</i>, он указывают на тот же коммит, что и указатель <i>origin/serverfix</i>.
        <pre><code>$ git rev-parse origin/serverfix
28b529332be1d8bc8110bec50774d92d2e5d8f05

$ git rev-parse fix
28b529332be1d8bc8110bec50774d92d2e5d8f05</code></pre>
        <p>
            Информация о том какие локальные ветки отслеживают удаленные ветки, хранится в локальном конфигурационном файле.
            Так команда из предыдущего примера добавит в локальный конфигурационный файл такой раздел
        <pre><code>[branch "fix"]
	remote = origin
	merge = refs/heads/serverfix</code></pre>
        <p>
            Сделать так, чтобы текущая ветку отслеживала нужную удаленную ветку можно командой <i>git branch</i> с ключом <i>-u</i> или <i>--set-upstream-to</i>.
            <br>
            Формат команды: <i>git branch -u &lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;</i>.
            <br>
            Той же командой можно переназначать отслеживаемые ветки.
        </p>
        <p>
            Создать новую локальную ветку с идентификатором удаленной ветки, назначит вторую отслеживаемой и сразу же переключиться на созданную ветку, можно командой <i>git checkout --track &lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;</i>.
            <br>
            Эта команда создает локальную ветку с именем как у удаленной ветки.
            <br>
            При этом созданная ветка, будет отслеживать указанную удаленную ветку.
        <pre><code>$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'</code></pre>
        <p>
            Команда <i>git checkout -b &lt;ветка1&gt; &lt;удалённый_репозиторирий&gt;/&lt;ветка2&gt;</i> работает как и предыдущая, но создает локальную ветку с именем, отличным от имени удалённой ветки. Например:
        <pre><code>$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'</code></pre>
        Теперь ваша локальная ветка <i>sf</i> будет отслеживать удаленную ветку <i>origin/serverfix</i>.
        <p>
            Посмотреть список всех локальных веток, с информацией о том у каких веток есть отслеживаемые ветки, и на сколько коммитов локальные ветки опережают отслеживаемые или отстают от них, можно командой <i>git branch</i> с опцией <i>-vv</i>.
            Пример вывода:
        <pre><code>$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new</code></pre>
        <p>
            Вывод команды показывает, что:
            <br>
            - ветка <i>iss53</i> отслеживает ветку <i>origin/iss53</i> и что локальная ветка опережает на два изменения, т.е. мы имеем два локальных коммита, которые не отправлены на сервер.
            <br>
            - ветка <i>master</i> отслеживает ветку <i>origin/master</i> и что локальная ветка в актуальном состоянии.
            <br>
            - ветка <i>serverfix</i> отслеживает ветку <i>server-fix-good/teamone</i> и что локальная ветка опережает на три коммита и отстает на один, т.е. есть один коммит на сервере, который мы еще не слили с веткой <i>serverfix</i> и три локальных коммита, которые вы еще не отправили.
            <br>
            - ветка <i>testing</i> не отслеживает удаленную ветку.
        </p>
        <p>
            Эта команда не обращается к серверам.
            Данные об отставании или опережении основана на информации, которая получена при последнем подключении к удаленным репозиториям.
            Если вы хотите полностью быть в курсе опережающих и отстающих коммитов, вам необходимо извлечь данные из всех ваших удаленных репозиториев перед запуском этой команды. Например так:
        <pre><code>$ git fetch --all; git branch -vv</code></pre>
        <p>
            Если локальная ветка отслеживает ветку <i>&lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;</i>, то в команде <i>git</i> ссылаться на эту отслеживаемую ветку можно с помощью конструкции <i>@{upstream}</i> или, что тоже самое <i>@{u}</i>.
            <br>Так, если вы находитесь на ветке <i>master</i>, которая отслеживает <i>origin/master</i>, то вместо <i>git merge origin/master</i> вы можите написать <i>git merge @{u}</i>.
        </p>

        <h3>Команда <i>git pull</i></h3>

        <p>
            Команда <i>git pull</i>, по существу является эквивалентом двух последовательно выполняемых команд <i>git fetch</i> и <i>git merge</i>.
            <br>
            Так команда <i>git pull &lt;удалённый_репозиторирий&gt;</i> сначала получить все изменения с <i>&lt;удалённый_репозиторирий&gt;</i>, проделав тоже, что и <i>git fetch &lt;удалённый_репозиторирий&gt;</i>, а затем сольет текущую ветку с соответствующей отслеживаемой удаленной веткой.
            <br>
            Если у текущей ветки есть отслеживаемая удаленная ветка &lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;, то она сольется с текущей, как по команде <i>git merge &lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;</i>.
            <br>
            Если текущая ветка не отслеживает никакую удаленную, то операция слияния не выполняется.
        </p>
        <p>
            Если находясь на ветке, у которой есть отслеживаемая удаленная ветка, вы наберёте <i>git pull</i> или <i>git pull</i> без указания удаленного репозитория, команда получит изменения из репозитория, имя которого входит в имя отслеживаемой удалённой ветки.
            Например если текущей веткой является ветка <i>master</i> и она отслеживает ветку <i>origin/master</i>, то изменения будут получены с репозитория <i>origin</i>.
        </p>
        <p>
            Магия <i>git pull</i> может часто сбивать с толку, поэтому обычно лучше явно использовать команды <i>git fetch</i> и <i>git merge</i>.
        </p>

        <h3>Отправка изменений в удаленный репозиторий. Команда <i>git push</i></h3>

        <p>
            Когда вы хотите поделиться своими наработками с другими, вам необходимо отправить (push) изменения в удаленный репозиторий, к которому у вас есть доступ на запись.
            <br>
            Не все ваши локальные ветки будут синхронизируются с удалёнными репозиториями.
            Вам нужно явно указать ветки, которыми вы хотите поделиться.
            Т.о вы можете отправлять только те тематические ветки, над которыми вы работаете совместно с другими,
            и не отправлять другие ветки, которые вы не хотите показывать.
        </p>

        <p>
            Формат команды: <i>git push &lt;имя_удаленного_репозитория&gt; &lt;имя_лок_ветки&gt;:&lt;имя_удал_ветки&gt;</i>
            <br>
            Можно использовать этот формат для отправки локальной ветки в удалённую ветку с другим именем.
            <br>
            Когда имя ветки в локальном и удаленном репозитории совпадают, формат команда можно упростить:
            <i>git push &lt;имя_удаленного_репозитория&gt; &lt;имя_ветки&gt;</i>
        </p>
        <p>
            Например:
        <pre><code>$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -&gt; serverfix</code></pre>
        <p>
            Если команду <i>git push</i> выполнить без параметров, то будут отправлены изменения текущей ветки, но только если у неё есть отслеживаемая удаленная ветка.
            Команда отправит изменения в тот репозиторий, имя которого входит в имя отслеживаемой удалённой ветки.
            Например если текущей веткой является ветка <i>master</i> и она отслеживает ветку <i>origin/master</i>, то изменения будут отправлены в репозиторий <i>origin</i>.
        </p>
        <p>
            Когда обычные (не голые) репозитории подсоединяются в качестве удаленных в отношении них есть такое ограничение -
            обновлять текущую ветку в удаленном репозитории запрещено.
            <br>
            Это сделало бы состояние индекса и рабочего каталога противоречивым.
            <br>
            Вам прийдется выполнить «git reset --hard», чтобы состояние рабочего каталога снова соответствовало HEAD.
        <p></p>
        Такова настройка git по умолчанию.
        Однако вы можете установить значение опции «receive.denyCurrentBranch» в «ignore» или «warn» во внешнем репозитории,
        чтобы разрешить отправку в его текущую ветку; но это не рекомендуется, если только вы не намерены обновить его
        рабочий каталог способом подобным
        вышеописанному.

        <h3>Удаление веток в удалённом репозитории</h3>

        <p>
            Скажем, вы и ваши соавторы закончили с нововведением и слили его в ветку <i>master</i> в удалённом репозитории (или в какую-то другую ветку, где хранится стабильный код).
            Вы можете удалить ветку в удалённом репозитории, используя команду <i>git push</i> с опцией <i>--delete</i>.
            Если вы хотите удалить ветку <i>serverfix</i> в репозитории <i>origin</i>, выполните следующее:
        <pre><code>$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix</code></pre>
        <p>
            Команда удаляет только указатель на ветку в удаленном репозитории, коммиты этой ветки она не трогает.
            Коммиты удаленных веток (и другие недоступные объекты) периодически??? удаляет сборщик мусора.
            Если ветка была удалена случайно, чаще всего ее легко восстановить.
        </p>

    </div>
</BODY>

</HTML>
