<HTML lang="ru">

<HEAD>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
    <TITLE>Git не для чайников (часть 2.2)</TITLE>
    <meta name="KeyWords" content="git">
</HEAD>

<BODY>

    <div style="width:85%;  margin: auto;">

        <p><a href="http://htmlpreview.github.io/?https://github.com/konstant-in/doc1/blob/master/Git2.html">оригинал</a></p>

        <h3>Удаленные репозитории</h3>

        <p>
            Git позволяет работая в одном репозитории получать и принимать изменения из другого репозитория.
            В этом случае первый репозиторий называется <i>локальным</i>, а второй - <i>удаленным</i>.
        </p>
        <p>
            Удаленный репозиторий может располагаться на том же компьютере, что и локальный, в локальной сети, или где то в интернете. Главное у пользователя должен быть доступ к нему одним из способов, который поддерживает <i>git</i>.
            Для получения изменений достаточно иметь доступ на чтение, для передачи изменений нужен доступ на запись.
        </p>
        <p>
            Вначале надо <i>подсоединить</i> удаленный репозиторий к локальному, т.е. указать указать где он находится, при помощи <i>URL</i> и присвоить ему <i>имя (shortname)</i>.
            <br>
            Подсоединение выполняется командой <i>git remote add &lt;shortname&gt; &lt;url&gt;</i>.
            <br>
            (??? Подсоединение удаленного репозитория выполняется автоматически при его клонировании (см. далее). ???)
        </p>
        <p>
            Информация о подсоединенных репозиториях хранится в локальном конфигурационном файле репозитория.
        </p>
        <p>
            Пусть у нас имеется репозиторий в текущей папке и репозиторий по пути <i>/home/Thomas/project1</i>, с которым мы хотим работать как с удаленным репозиторием. Так команда
        <pre><code>$ git remote add origin /home/Thomas/project1</code></pre>
        подсоединяет удаленный репозиторий <i>/home/Thomas/project1</i> и назначает ему имя <i>origin</i>.
        Информация об этом сохраняется в разделе [remote "origin"] локального конфигурационного файла.
        <pre><code>[remote "origin"]
	url = /home/Thomas/project1
	fetch = +refs/heads/*:refs/remotes/origin/*</code></pre>
        <p>
            Командой <i>git remote</i> без параметров можно посмотреть список всех подсоединенных удаленных репозиториев.
            <br>
            Эта же команда с параметром «-v» выводит дополнительно URL удаленных репозиториев.
        </p>
        <p>
            Например:
        <pre><code>$ git remote
origin

$ git remote -v
origin	/home/Thomas/project1 (fetch)
origin	/home/Thomas/project1 (push)</code></pre>
        <p>
            Команда <i>git remote add</i> с дополнительными параметрами может установить разные URL для чтения (fetch) и записи (push).
        </p>

        <h3>Работа с удаленными репозиториями по сети</h3>

        <p>
            Git работает с удаленными репозиториями по локальным сетям точно также, как с репозиториями на вашем компьютере.
            У вас должна быть права на чтение и запись в папку .git репозитория.
            Кроме того работать с удаленными репозиториями можно по протоколам: HTTP/HTTPS, SSH (Secure Shell) и Git.
            Сетевого протокола протокол выбирается на основании URL.
        </p>
        <p>
            URL (Uniform Resource Locator, унифицированный указатель ресурса) — система унифицированных адресов электронных ресурсов, или единообразный определитель местонахождения ресурса (например файла).
        </p>
        <p>
            Структура URL:
            <br>
            <i>&lt;схема&gt;</i>:[//[<i>&lt;логин&gt;</i>[:<i>&lt;пароль&gt;</i>]@]<i>&lt;хост&gt;</i>[:<i>&lt;порт&gt;</i>]][/<i>&lt;URL-путь&gt;</i>]
            <br>
            где:
            <br>
            <i>схема</i> - схема обращения к ресурсу; в большинстве случаев имеется в виду сетевой протокол
            <br>
            <i>логин</i> - имя пользователя, используемое для доступа к ресурсу
            <br>
            <i>пароль</i> - пароль указанного пользователя
            <br>
            <i>хост</i> - полностью прописанное доменное имя хоста в системе DNS или IP-адрес хоста в форме четырёх групп десятичных чисел, <br>
            разделённых точками; числа — целые в интервале от 0 до 255.
            <br>
            <i>порт</i> - порт хоста для подключения
            <br>
            <i>URL-путь</i> - уточняющая информация о месте нахождения ресурса; зависит от протокола.
        </p>

        <h3>Голые репозитории</h3>

        <p>
            Помимо <i>обычных</i> репозиториев, с которыми мы до сих пор имели дело, бывают т.н. <i>голые (чистые, bare)</i> репозитории.
            Голые репозитории не имеют своего рабочего каталога.
            Они используются только в качестве удаленных репозиториев для обмена изменениями между обычными репозиториями.
        </p>
        <p>
            Такие репозитории создаются командой <i>git init</i> с параметром <i>--bare</i>.
            Имя каталога голого репозитория указывается при создании и может быть любым, но принято чтобы оно заканчивалось на «.git».
        <pre><code>
$ git init --bare test.git -b master
</code></pre>

        <h3>Создание клонов репозитория. Команда <i>git clone</i></h3>

        <p>
            Существующий репозиторий можно склонировать командой <i>git clone</i>.
            Тип клонируемого репозитория может быть любым - обычным или голым.
            Тип у клона может не совпадать с исходным.
            Голый репозиторий создается командой <i>git clone</i> с опцией <i>--bare</i>, по умолчанию - обычный репозиторий.
        </p>
        <p>
            При клонировании репозитория происходит почти точное копирование существующего репозитория (чем отличаются см. ...).
            Если клон является обычным репозиторием, то клонируемый репозиторий подсоединяется к клону как удаленный, с именем «origin».
        </p>
        <p>
            При клонировании копируется указатель текущей ветки и он становится указателем текущей веткой репозитория-клона.
            Автоматически эта ветка становится отслеживающей соответствующую удаленную ветку (что это значит см. долее).
        </p>
        <p>
            Обычно репозитории клонируют с текущей веткой <i>master</i>.
        </p>
        <p>
        <pre><code>$ git clone /home/Thomas/project1 pr1_c

$ cd pr1_c

$ git remote
origin

$ git remote -v
origin	/home/Thomas/project1 (fetch)
origin	/home/Thomas/project1 (push)</code></pre>

        <h3>Получение изменений из удаленного репозитория. Команда <i>git fetch</i></h3>

        <p>
            Команда <i>git fetch</i> загрузит с сервера все изменения, которых у вас еще нет.
            <br>
            Все новые объекты загружаются в локальную базу объектов <i>.git/objects</i>.
            <br>
            Каталог <i>.git/refs/remotes/&lt;имя_удаленного_репозитория&gt;</i> приводится в соответствие с каталогом <i>.git/refs/</i> удаленного репозитория. ????*************
        </p>
        <p>
            Указатели удаленного репозитория сокращенно называются <i>удаленными указателями</i>.
            Их имена, в локальном репозитории, состоят из имени удаленного репозитория и имени, которое они имеют в удаленном репозитории, разделенных косой чертой.
            Например указатель <i>master</i> удаленного репозитория <i>origin</i> в локальном репозитории имеет имя <i>origin/master</i>.
        </p>
        <p>
            Обратите внимание на то, что локальные и удаленные указатели ведут себя по разному.
            Если локальные указатели двигаются когда мы делаем коммиты в локальном репозитории, то удаленные указатели двигаются, когда мы получаем изменения из удаленного репозитория.
        </p>
        <p>
            Команда <i>git fetch</i> не меняет содержимого вашего рабочего каталога!
        </p>
        <p>
            После получения изменений из удаленного репозитория можно выполнить слияние командой <i>git merge</i> и
            привести файлы вашего рабочего каталога в соответствие с полученными изменениями.
        </p>

        <p>
            Получим обновлений из удаленного репозитория <i>origin</i>. Для этого выполним команду
        <pre><code>$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -&gt; origin/serverfix</code></pre>
        Вывод команды показывает, что из удаленного репозитория мы получили 7 новых (для нас) объектов и новый (для нас) указатель <i>serverfix</i>, ставший у нас удалённым указатель <i>origin/serverfix</i>.
        При этом локальный указатель на ветку <i>serverfix</i> создан не был!
        <p>
            Все удаленные указатели можно посмотреть командой <i>git branch</i> с опцией <i>-r</i>
        <pre><code>$ git branch -r
  origin/master
  origin/serverfix</code></pre>
        <p>
            Вы можите временно переключится на удаленную ветку, чтобы посмотреть новые файлы рабочего каталога (работать в удаленной ветке не получиться)
        <pre><code>$ git checkout origin/serverfix</code></pre>
        или слить удаленную ветку со своей текущей веткой
        <pre><code>git merge origin/serverfix</code></pre>

        <h3>Отслеживание веток</h3>

        <p>
            Чуть позже мы будем изучать команды работающие с удаленными репозиториями и использующие т.н. <i>отслеживаемые ветки (upstream branches)</i>.
            Отслеживаемая ветка - это ветка удаленного репозитория, которая определенным образом связана с локальной веткой.
            Отслеживаемых веток может быть сколько угодно и они могут быть из разных удаленных репозиториев.
        </p>
        <p>
            Создать локальную ветку, с тем же идентификатором как у удаленной ветки, и одновременно сделать, чтобы она отслеживала эту удаленную ветку, можно командой <i>git branch &lt;ветка1&gt; &lt;удалённый_репозиторирий&gt;/&lt;ветка2&gt;</i>.
        </p>
        <p>
            Например команда
        <pre><code>$ git branch fix origin/serverfix
Branch 'fix' set up to track remote branch 'serverfix' from origin.</code></pre>
        создает ветку <i>fix</i> и назначает ей ветку <i>origin/serverfix</i> как отслеживаемую.
        После создания указателя <i>fix</i>, он указывают на тот же коммит, что и указатель <i>origin/serverfix</i>.
        <pre><code>$ git rev-parse origin/serverfix
28b529332be1d8bc8110bec50774d92d2e5d8f05

$ git rev-parse fix
28b529332be1d8bc8110bec50774d92d2e5d8f05</code></pre>
        <p>
            Информация о том какие локальные ветки отслеживают удаленные ветки, хранится в локальном конфигурационном файле.
            Так команда из предыдущего примера добавит в локальный конфигурационный файл такой раздел
        <pre><code>[branch "fix"]
	remote = origin
	merge = refs/heads/serverfix</code></pre>
        <p>
            Сделать так, чтобы текущая ветку отслеживала нужную удаленную ветку можно командой <i>git branch</i> с ключом <i>-u</i> или <i>--set-upstream-to</i>.
            <br>
            Формат команды: <i>git branch -u &lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;</i>.
            <br>
            Той же командой можно переназначать отслеживаемые ветки.
        </p>
        <p>
            Создать новую локальную ветку с идентификатором удаленной ветки, назначит вторую отслеживаемой и сразу же переключиться на созданную ветку, можно командой <i>git checkout --track &lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;</i>.
            <br>
            Эта команда создает локальную ветку с именем как у удаленной ветки.
            <br>
            При этом созданная ветка, будет отслеживать указанную удаленную ветку.
        <pre><code>$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'</code></pre>
        <p>
            Команда <i>git checkout -b &lt;ветка1&gt; &lt;удалённый_репозиторирий&gt;/&lt;ветка2&gt;</i> работает как и предыдущая, но создает локальную ветку с именем, отличным от имени удалённой ветки. Например:
        <pre><code>$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'</code></pre>
        Теперь ваша локальная ветка <i>sf</i> будет отслеживать удаленную ветку <i>origin/serverfix</i>.
        <p>
            Посмотреть список всех локальных веток, с информацией о том у каких веток есть отслеживаемые ветки, и на сколько коммитов локальные ветки опережают отслеживаемые или отстают от них, можно командой <i>git branch</i> с опцией <i>-vv</i>.
            Пример вывода:
        <pre><code>$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new</code></pre>
        <p>
            Вывод команды показывает, что:
            <br>
            - ветка <i>iss53</i> отслеживает ветку <i>origin/iss53</i> и что локальная ветка опережает на два изменения, т.е. мы имеем два локальных коммита, которые не отправлены на сервер.
            <br>
            - ветка <i>master</i> отслеживает ветку <i>origin/master</i> и что локальная ветка в актуальном состоянии.
            <br>
            - ветка <i>serverfix</i> отслеживает ветку <i>server-fix-good/teamone</i> и что локальная ветка опережает на три коммита и отстает на один, т.е. есть один коммит на сервере, который мы еще не слили с веткой <i>serverfix</i> и три локальных коммита, которые вы еще не отправили.
            <br>
            - ветка <i>testing</i> не отслеживает удаленную ветку.
        </p>
        <p>
            Эта команда не обращается к серверам.
            Данные об отставании или опережении основана на информации, которая получена при последнем подключении к удаленным репозиториям.
            Если вы хотите полностью быть в курсе опережающих и отстающих коммитов, вам необходимо извлечь данные из всех ваших удаленных репозиториев перед запуском этой команды. Например так:
        <pre><code>$ git fetch --all; git branch -vv</code></pre>
        <p>
            Если локальная ветка отслеживает ветку <i>&lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;</i>, то в команде <i>git</i> ссылаться на эту отслеживаемую ветку можно с помощью конструкции <i>@{upstream}</i> или, что тоже самое <i>@{u}</i>.
            <br>Так, если вы находитесь на ветке <i>master</i>, которая отслеживает <i>origin/master</i>, то вместо <i>git merge origin/master</i> вы можите написать <i>git merge @{u}</i>.
        </p>

        <h3>Команда <i>git pull</i></h3>

        <p>
            Команда <i>git pull</i>, по существу является эквивалентом двух последовательно выполняемых команд <i>git fetch</i> и <i>git merge</i>.
            <br>
            Так команда <i>git pull &lt;удалённый_репозиторирий&gt;</i> сначала получить все изменения с <i>&lt;удалённый_репозиторирий&gt;</i>, проделав тоже, что и <i>git fetch &lt;удалённый_репозиторирий&gt;</i>, а затем сольет текущую ветку с соответствующей отслеживаемой удаленной веткой.
            <br>
            Если у текущей ветки есть отслеживаемая удаленная ветка &lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;, то она сольется с текущей, как по команде <i>git merge &lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;</i>.
            <br>
            Если текущая ветка не отслеживает никакую удаленную, то операция слияния не выполняется.
        </p>
        <p>
            Если находясь на ветке, у которой есть отслеживаемая удаленная ветка, вы наберёте <i>git pull</i> или <i>git pull</i> без указания удаленного репозитория, команда получит изменения из репозитория, имя которого входит в имя отслеживаемой удалённой ветки.
            Например если текущей веткой является ветка <i>master</i> и она отслеживает ветку <i>origin/master</i>, то изменения будут получены с репозитория <i>origin</i>.
        </p>
        <p>
            Магия <i>git pull</i> может часто сбивать с толку, поэтому обычно лучше явно использовать команды <i>git fetch</i> и <i>git merge</i>.
        </p>

        <h3>Отправка изменений в удаленный репозиторий. Команда <i>git push</i></h3>

        <p>
            Когда вы хотите поделиться своими наработками с другими, вам необходимо отправить (push) изменения в удаленный репозиторий, к которому у вас есть доступ на запись.
            <br>
            Не все ваши локальные ветки будут синхронизируются с удалёнными репозиториями.
            Вам нужно явно указать ветки, которыми вы хотите поделиться.
            Т.о вы можете отправлять только те тематические ветки, над которыми вы работаете совместно с другими,
            и не отправлять другие ветки, которые вы не хотите показывать.
        </p>

        <p>
            Формат команды: <i>git push &lt;имя_удаленного_репозитория&gt; &lt;имя_лок_ветки&gt;:&lt;имя_удал_ветки&gt;</i>
            <br>
            Можно использовать этот формат для отправки локальной ветки в удалённую ветку с другим именем.
            <br>
            Когда имя ветки в локальном и удаленном репозитории совпадают, формат команда можно упростить:
            <i>git push &lt;имя_удаленного_репозитория&gt; &lt;имя_ветки&gt;</i>
        </p>
        <p>
            Например:
        <pre><code>$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -&gt; serverfix</code></pre>
        <p>
            Если команду <i>git push</i> выполнить без параметров, то будут отправлены изменения текущей ветки, но только если у неё есть отслеживаемая удаленная ветка.
            Команда отправит изменения в тот репозиторий, имя которого входит в имя отслеживаемой удалённой ветки.
            Например если текущей веткой является ветка <i>master</i> и она отслеживает ветку <i>origin/master</i>, то изменения будут отправлены в репозиторий <i>origin</i>.
        </p>
        <p>
            Когда обычные (не голые) репозитории подсоединяются в качестве удаленных в отношении них есть такое ограничение -
            обновлять текущую ветку в удаленном репозитории запрещено.
            <br>
            Это сделало бы состояние индекса и рабочего каталога противоречивым.
            <br>
            Вам прийдется выполнить «git reset --hard», чтобы состояние рабочего каталога снова соответствовало HEAD.
        <p></p>
        Такова настройка git по умолчанию.
        Однако вы можете установить значение опции «receive.denyCurrentBranch» в «ignore» или «warn» во внешнем репозитории,
        чтобы разрешить отправку в его текущую ветку; но это не рекомендуется, если только вы не намерены обновить его
        рабочий каталог способом подобным
        вышеописанному.

        <h3>Удаление веток в удалённом репозитории</h3>

        <p>
            Скажем, вы и ваши соавторы закончили с нововведением и слили его в ветку <i>master</i> в удалённом репозитории (или в какую-то другую ветку, где хранится стабильный код).
            Вы можете удалить ветку в удалённом репозитории, используя команду <i>git push</i> с опцией <i>--delete</i>.
            Если вы хотите удалить ветку <i>serverfix</i> в репозитории <i>origin</i>, выполните следующее:
        <pre><code>$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix</code></pre>
        <p>
            Команда удаляет только указатель на ветку в удаленном репозитории, коммиты этой ветки она не трогает.
            Коммиты удаленных веток (и другие недоступные объекты) периодически??? удаляет сборщик мусора.
            Если ветка была удалена случайно, чаще всего ее легко восстановить.
        </p>

        <h3>Удаление и переименование удалённых репозиториев</h3>

        <p>
            стр. 51
        </p>

        <h3>Псевдонимы git</h3>

        <p>
            стр. 56-57
        </p>


        <h3>Github в качестве удаленного репозитория</h3>
        <p>
            ******************
        </p>

        <h4>Копирование репозитория с другого компьютера</h4>

        <p>
            Если на каком то компьютере у вас уже есть репозиторий Git, то чтобы скопировать его на другой компьютер достаточно:
            <br>
            1) из существующего репозитория скопировать в пустой каталог второго компьютера только каталог <i>.git/</i>;
            <br>
            2) восстановить рабочие файлы и каталоги командой:
        <pre><code style="color: blue">   $ git checkout HEAD .
</code></pre>
        или
        <pre><code style="color: blue">   $ git checkout .
</code></pre>
        или
        <pre><code style="color: blue">   $ git reset --hard HEAD
</code></pre>

        <h4>Клонирование существующего репозитория с github</h4>

        <p>Клонирование репозитория с github осуществляется командой git clone [url].
            <br>
            После клонирования репозитория автоматически производится и восстановление файлов рабочего каталога???
            <br>
            Например, если вы хотите клонировать репозиторий konstant-in/example1. Вы можете сделать это следующим образом:

        <pre><code style="color: blue">   $ git clone https://github.com/konstant-in/example1.git
</code></pre>

        <p>Эта команда создаёт директорию “libgit2”, инициализирует в ней поддиректорию .git, скачивает все данные для этого репозитория и создаёт (checks out) рабочую копию последней версии. Если вы зайдёте в новую директорию libgit2, то увидите в ней файлы проекта, готовые для работы или использования. Для того, чтобы клонировать репозиторий в директорию с именем, отличающимся от “libgit2”, необходимо указать желаемое имя, как параметр командной строки:
        <pre><code style="color: blue">   $ git clone https://github.com/konstant-in/example1.git my_example1</code></pre>
        Эта команда делает всё то же самое, что и предыдущая, только результирующий каталог будет назван my_example1.
        <p>
            Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый
            репозиторий под именем «origin».
        </p>


        <h4>Восстановление состояния рабочего каталога. Команда git checkout *******************</h4>

        <p>
            Имея в распоряжении слепки системы, можно восстановить отдельные файлы или всю иерархию файлов и подкаталогов рабочего каталога.
        </p>
        <p>
            Ни одна из команд восстановления не затрагивают базу объектов репозитория. Её состояние всегда остается без изменения.
        </p>
        <p>
            Для этого можно воспользоваться командой:
        <pre><code style="color: blue">
   git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​
</code></pre>
        &lt;pathspec&gt; - один файл, список файлов (разделенных пробелами), * (звездочка) или . (точка).
        <br>
        Чем * (звездочка) отличается от . (точка)???????????
        <br>
        <br>
        Overwrite paths in the working tree by replacing with the contents in the index or in the &lt;tree-ish&gt; (most often a commit). When a &lt;tree-ish&gt; is given, the paths that match the &lt;pathspec&gt; are updated both in the index and in the working tree.
        <br>
        <br>
        Когда не задан &lt;tree-ish&gt;, то пути, соответствующие &lt;pathspec&gt;, обновляются в рабочем каталоге содержимым из индекса.
        <br>
        Когда &lt;tree-ish&gt; задан, то пути, соответствующие &lt;pathspec&gt;, обновляются содержимым из &lt;tree-ish&gt; как в индексе, так и в рабочем каталоге.
        <br>
        <br>
        The index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using -f will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using --ours or --theirs. With -m, changes made to the working tree file can be discarded to re-create the original conflicted merge result.
        <br>
        <br>
        Индекс может содержать не объединенные записи из-за предыдущего неудачного слияния. По умолчанию, если вы
        попытаетесь извлечь такую запись из индекса, операция извлечения завершится неудачей и ничего не будет извлечено.
        Использование -f будет игнорировать эти необработанные записи. Содержимое с определенной стороны слияния можно
        извлечь из индекса с помощью --ours или --theirs. С помощью -m изменения, внесенные в файл рабочего дерева, можно
        отменить, чтобы заново создать исходный конфликтующий результат слияния.

        <h5>Пример восстановление</h5>

        <p>Удалим все файла в рабочем каталоге из прошлого примера. Затем восстановим содержимое по первому слепку.</p>

        <p>*********</p>

        <p>Второй раз удалим все файла в рабочем каталоге и восстановим содержимое по второму слепку.</p>

        <p>*********</p>


        <p>
            **************^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***********************
        </p>

        <h2>В ЗАКЛЮЧЕНИИ (Delta-сжатие)</h2>

        <p>
            До вызова git-repack (или включающего его git gc) блобы хранятся отдельно, но каждый объект (блоб, дерево, коммит, тег) хранится в сжатом виде (сжатие zlib).
        </p>
        <p>
            Delta-сжатие появляется после вызова git repack или git gc. Во время этого процесса все неупакованные объекты объединяются в .pack - файлы, где помимо обычного сжатия, применяется еще дельта-сжатие.
        </p>
        <p>
            У дельта-сжатия два параметра - окно (window) и глубина (depth).
            Чтобы применить дельта-сжатие, git pack-objects (вызываемый из git repack) сравнивает куски объектов, применяет к ним дельта-сжатие (то есть образно говоря дифф) и смотрит, получилось ли сэкономить на дельта-сжатии место. Если получилось - то в архив кладется первый объект и дифф до второго. При этом также используется сортировка по типу (вряд ли блоб будет давать хорошую дельту относительно коммита или дерева), затем по размеру (и опционально по имени объекта). Получается список объектов. Для каждого объекта в этом списке проверяются на "дельта-совместимость" ближайшие в списке объекты, находящиеся в рамках "окна" (window). По умолчанию на совместимость проверяется 10 объектов, но этот параметр можно увеличить. По результатам проверки выбирается объект с минимальной дельтой (это может быть в принципе объект, который также является дельтой третьего объекта - в таком случае говорят, что тут глубина дельты равна 2).
        </p>
        <p>
            Также по умолчанию глубина дельта-сжатия - 50, то есть ориентировочно 50 версий одного и того же файла хранятся в виде дельт относительно друг друга, а пятьдесят первая - в виде полной версии файла. Далее следующие 50 версий этого файла будут опять в виде дельт. Это нужно для ускорения получения блобов - иначе при допустим 1000 изменениях в одном файле последнюю версию надо будет получать, доставая первую и применяя к ней 1000 дельт, а это долго. 50 дельт считается разумным умолчанием. В этом случае достается 950-ая версия и к ней применяется 50 дельт, что в 20 раз быстрее.
        </p>
        <p>
            Варьируя параметры --window и --depth у git repack, можно находить подходящий компромисс между временем упаковки и распаковки объекта и занимаемым им местом. При этом параметр --window напрямую влияет на время упаковки (работы git repack), а --depth - на среднее время распаковки объекта.
        </p>
        <p>
            То есть, в норме - получается, сыпем при работе в папку .git файлики-объекты, и время от времени (когда захочется) вызываем упаковку насыпанного в очередной .pack?
        </p>
        <p>
            А git тем временем продолжает прозрачно (только чуть медленнее) работать как с россыпью новых файликов, так и с этими пакетами, как будто все файлики по-прежнему рассыпаны, и вовсе не упаковывались?
        </p>
        <p>
            Да, именно так. Плюс при передаче данных по сети (git push, git pull) тоже передаются пакеты, а не отдельные файлы.
        </p>

    </div>
</BODY>

</HTML>
