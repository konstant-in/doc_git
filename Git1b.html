<HTML lang="ru">

<HEAD>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
    <TITLE>Git не для чайников (часть 2.1b)</TITLE>
    <meta name="KeyWords" content="git">
</HEAD>

<BODY>

    <div style="width:85%;  margin: auto;">

        <p><a href="http://htmlpreview.github.io/?https://github.com/konstant-in/doc1/blob/master/Git1.html">оригинал</a></p>

        <h3>Указатели. Указатель <i>master</i></h3>

        <p>В системе git широко используется такая вещь, как указатель.
            <i>Указатель</i> это файл в каталоге <i>.git/refs/heads/</i> в котором хранится идентификатор коммита.
            В git-командах указатель можно использовать вместо идентификатора коммита.
            Имя указателя назначается только исходя из соображений удобства запоминания человеком.
            На имя указателя распространяются только ограничения наложенные на имена файлов.
            <br>
            В имени указателя допустимы прямые слеши (/).
            Если имя указателя будет содержать слеш, например iss/124, то указатель будет хранится в файле «124» в подкаталоге «iss».
        </p>
        <p>
            Указателей веток в репозитории может быть сколько угодно.
        </p>
        <p>
            Первый указатель создается автоматически, при создании первого коммита.
            Он получает имя <i>master</i> и в него записывается идентификатор этого коммита.
            Каждый вновь созданный коммит будет записывать в указатель master свой идентификатор,
            а в качестве родителя записывать предыдущее значение указателя. Например: ...
        </p>
        <p>
            Так будет происходить до тех пор пока текущим указателем будет оставаться указатель master.
            Текущий указатель хранится в файле .get/HEAD в формате: <i>ref: refs/heads/&lt;текущий_указатель&gt;</i>.
        </p>
        <p>
            Текущий указатель можно изменить командой <i>git checkout &lt;branchname&gt;</i>.
            Но прежде новый указатель надо создать командой <i>git branch &lt;branchname&gt; [&lt;commit-id&gt;]</i>.
            <br>
            Примечание: Если параметр &lt;commit-id&gt; опущен, то созданная указатель на текущий же коммит, но с другим именем.
        </p>
        <p>
            Поскольку все указатели хранятся в каталоге <i>.git/refs/heads/</i>, то один из способов посмотреть их список, выполнить команду ОС <i>find .git/refs/heads -type f</i>:
        <pre><code style="color: blue">
$ find .git/refs/heads -type f
.git/refs/heads/master
</code></pre>
        Для аналогичных целей служит команда git <i>git branch</i> (без параметров) :
        <pre><code style="color: blue">
$ git branch
* master
</code></pre>
        <p>
            Идентификатор коммита, хранящийся в указателе &lt;branchname&gt; можно посмотреть командой <i>git rev-parse &lt;branchname&gt;</i>, например:
        <pre><code style="color: blue">
$ git rev-parse master
e321b6cdf0bc52ca43effc8b975dbaa394baa9da
</code></pre>
        либо командой ОС:
        <pre><code style="color: blue">
$ cat .git/refs/heads/master
e321b6cdf0bc52ca43effc8b975dbaa394baa9da
</code></pre>

        <h4>Символические указатели</h4>

        <p>
            Символическими указателями являются файлы хранящие ссылки на указатель в формате: <i>ref: refs/heads/&lt;указатель&gt;</i>.
            Все символические указатели, хранятся непосредственно в каталоге .git/.
        </p>
        <p>
            Все??? символические указатели создаются автоматически???
            Они имеют имена В ВЕРХНЕМ РЕГИСТРЕ.
            Наиболее важными символическими ссылками являются: HEAD, ORIG_HEAD и MERGE_HEAD.
        </p>
        <p>
            Символический указатель, с именем HEAD мы уже рассмотрели.
        </p>

        <h4>Ветки</h4>

        <p>
            В книге по git постоянно используется термин ветка. Однако в разных местах в этот термин вкладывается разный смысл. То это некая последовательность коммитов (не очень понятго какая), то указатель на коммит.
            Мы веткой будем называть только последовательность символов (ниже четко определим какую именно).
            Указатели ветками мы никогда называть не будем.
        </p>
        <p>
            <i>Ветка</i> - цепочка коммитов начинающаяся с некоторого указателя, идущая вниз и включающая в себя все коммит-объекты, созданные когда текущим был этот коммит. (Коммит-оъекты создаются не только командой <i>git commit</i>, но и <i>git merge</i> [коммиты слияния]).
            <br>
            Т.о. каждый указатель определяет свою ветку. Имя указателя одновременно является именем соответствующей ветки.
        </p>
        <p>
            Прежде чем создать новую ветку надо создать новый указатель, сделать его текущим.
            Коммиты созданные после этого будут относится к новой ветке.
        </p>
        <p>
            Склонируем проект project1 в папку project2
        <pre><code style="color: blue">
$ git clone project1 project2
Cloning into 'project2'...
done.

$ cd project2

$ get status
bash: get: command not found

$ git branch
* master

$ git log
commit 344b36ba2aeb489f97a4928816eeeefb30ddfac2 (HEAD -> master, origin/master, origin/HEAD)
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:03:00 2000 +0200

    comment #3

commit 03c1a7f12800978dde0b8cd6383595e7007d0098
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:02:00 2000 +0200

    comment #2

commit 69701b6e701d429882c083e98e1ecf195868b38c
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:01:00 2000 +0200

    comment #1
</code></pre>
        Указатель master у нас уже есть. Он указывает на коммит 6970.
        <pre><code style="color: blue">
$ git rev-parse master
344b36ba2aeb489f97a4928816eeeefb30ddfac2
</code></pre>
        Создадим второй указатель с именем test указывающий на коммит (03c1).
        <pre><code style="color: blue">
$ git branch test 03c1

$ git rev-parse test
03c1a7f12800978dde0b8cd6383595e7007d0098
</code></pre>
        <p>
            Переключиться на указатель &lt;branchname&gt; можно командой <i>git checkout &lt;branchname&gt;</i>.
            Давайте переключаемся на созданный указатель test, посмотрим log, затем вернемся на master и снова посмотрим log.
        </p>
        <p>
        <pre><code style="color: blue">
$ git checkout test
Switched to branch 'test'

$ git log --oneline
03c1a7f (HEAD -> test) comment #2
69701b6 comment #1

$ git checkout master
Switched to branch 'master'
Your branch is up to date with 'origin/master'.

$ git log --oneline
344b36b (HEAD -> master, origin/master, origin/HEAD) comment #3
03c1a7f (test) comment #2
69701b6 comment #1
</code></pre>
        Ветка master состоит из коммитов 344b36b -> 03c1a7f -> 69701b6, а ветка test пока пустая.
        <p>
            Текущий указатель, в выводе команды <i>git branch</i>, отмечается звездочкой (*).
        <pre><code style="color: blue">
$ git branch
* master
  test
</code></pre>

        <h3>Ветвление в git</h3>

        <p>
            стр.58-...
        </p>

        <h3>Слияние в git</h3>

        <p>
            В классическом случае операция слияния - это
            <br><br>
            1. Формирование нового дерева, которое каким-то образом включает в себя изменения, произошедшие в сливаемых ветках со времени их общего предка.
            <br><br>
            2. Формирование нового коммита с этим деревом, в качестве предков которого указаны все сливаемые коммиты
        </p>
        <p>
            Автоматическая система слияния git в многих случаях может сама "слить" ветки, без участия пользователя. Например, если изменения в сливаемых ветках затрагивают разные файлы, или один и тот же файл, но изменяемые строчки не пересекаются. Новое дерево в таком случае формируется автоматически.
        </p>
        <p>
            В общем случае новое дерево автоматически сформироваться не может из за того, что одни изменения конфликтуют с другими. *********
        </p>

        <h3>Метки</h3>

        <p>
            Метки как ссылки и метки как объекты.
        </p>
        <p>
            стр.52-56
        </p>

        <h4>Легковесные метки</h4>

        <p>
            <i>Легковесная метка(lightweight teg)</i> - файл хранящий идентификатор объекта любого типа (блоб, дерево, коммит или объект-метку).
            <br>
            Легковесную метку можно использовать в git-командах вместо идентификатора объекта.
            <br>
            Имя указателя назначается только исходя из соображений удобства запоминания человеком.
            <br>
            На имя указателя распространяются только ограничения наложенные на имена файлов.
            <br>
            Метка создается командой <i>git tag -s &lt;tagname&gt; &lt;object&gt;</i>.
            <br>
            Метки хранятся в каталоге <i>.git/refs/tags/</i>.
            <br>
            Нет штатных средств с помощью которых можно изменить идентификатор объекта на который она указывает. Будучи однажды созданной, она продолжает указывать на один и тот же объект.
        </p>

        <h4>Тяжеловесные или аннотированные теги (annotated tag)</h4>

        <p>
            <i>Тяжеловесные или аннотированные теги (annotated tag)</i> - это объект еще одного типа.
            <br>
            В тело этого объекта записываются следующие данные:
        <pre><code style="color: blue">     * идентификатор объекта, на который тот указывает.
     * Тип объекта, на который тот указывает (blob, tree, commit или tag) (да, бывают теги  указывающие на теги!)
     * Имя легковесной метки, указывающей на этот анонсированный тег, и которая создается одновременно с ним.
     * Дата и время создания тега
     * Имя и e-mail создателя тега (в таком же формате как имя автора коммита)
     * Кусок произвольных данных на усмотрение создателя тега
</code></pre>
        Объект создается командой <i>git tag -a &lt;tagname&gt; &lt;object&gt;</i>.
        <p>Вместе с анонсированной меткой создается легковесная метка указывающая на этот объект.</p>
        <p>
            В кусок произвольных данных могут быть записано сообщение тега (по смыслу аналогичное сообщению коммита), а также в него можно внедрить GPG-подпись объекта. Такой тег будет называться подписанным(tag).
        </p>
        <p>
            Вот тут и проявляется магия git - создавая подписанный тег на определенный коммит, на самом деле подписывается и сам коммит, и вся его история, и все деревья, составляющие историю, и все блобы, "висящие на ветках этих деревьев". То есть все, на что можно "дотянуться" по ссылкам от коммита.
        </p>


    </div>
</BODY>

</HTML>
