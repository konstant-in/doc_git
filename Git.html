<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <TITLE>Git не для чайников (часть 1)</TITLE>
    </head>
<BODY>
    <div style="width:85%;  margin: auto;">

        <p><a href="http://htmlpreview.github.io/?https://github.com/konstant-in/doc1/blob/master/Git.html">оригинал</a></p>

        <h1>Git не для чайников</h1>

        <h2>Для тех, кто хочет не только уметь с работать Git, но и понимать как тот устроен</h2>

        <p>
            Git это программный продукт относящийся к классу <i>систем контроля версий (СКВ, VCS)</i>.
            Любая система контроля версий как минимум должна:
            <br>
            1) уметь вести истории изменений файлов в заданном каталоге, храня старые версии файлов и информацию о том кто и когда эти изменения выполнил и
            <br>
            2) позволять восстанавливать, при необходимости, старых версий файлов.
        </p>
        <p>
            Git прекрасно справляется с этим и умеет делать много чего ещё.
            <br>
            Это кроссплатформенное ПО имеющее версии для операционных систем macOS, Windows, Linux/Unix.
        </p>
        <p>
            Git не имеет графического пользовательского интерфейса, т.к. является пакетом консольных утилит (утилит работающих в командной строке). Вся функциональность Git реализована через утилиты командной сроки,
            поэтому от читателей требуются элементарные навыки работы с командной строкой.
        </p>
        <p>
            Git это очень гибкая СКВ. С ней может работать как один человек, так и большая группа людей. Она позволяющая строить разные стратегии работы над проектами.
        <br>
            Когда с git работает один человек рабочий каталог и репозиторий может располагается на его компьютере.
        <br>
            Когда над одним проектом работают несколько человек, возможна схема, когда каждый работает со своим рабочим каталогом и репозиторием, расположенными на его компьютере.
            Время от времени пользователи обмениваются между собой информацией хранящейся в репозитории.
            Связь между компьютерами пользователей требуется только во время обмена информацией, а в остальное время можно работать совершенно автономно.
        <br>
            Git позволяет организовать централизованную систему с центральным репозиторием в локальной сети или в интернете.
            При этом каждый пользователей по прежнему работает со своим рабочим каталогом и репозиторием, расположенными у каждого на его компьютере и время от времени обмениваются информацией с центральным репозиторием.
            И в этом случае связь с центральным репозиторием требуется только во время обмена информацией.
        </p>

        <h3>Минимальная настройки git после инсталляции</h3>

        <p>После установки Git, настройте глобальный конфигурационный файл <i>.gitconfig</i>, хранящийся в домашнем каталоге пользователя (глобальный он для всех репозиториев с которыми работает пользователь).
            Для начала работы можно ограничится только указанием вашего имени, фамилии и адреса электронной почты.</p>
        <pre><code style="color: blue">
$ git config --global user.name "Ваши имя и фамилия в кавычках"
$ git config --global user.email "Ваш адрес электронной почты в кавычках"
</code></pre>
        Например:
        <pre><code style="color: blue">
$ git config --global user.name "Alex Petrov"
$ git config --global user.email "alex@localhost"
</code></pre>
        Если вы не выбрали редактор при инсталляции системы, можно выбрать это сейчас.
        Не оставляете в качестве редактора vim, если вы с ним никогда не работали.
        Если вы его видите первый раз, то работать с ним, и даже выйти из него, у вас не получится.
        <pre><code style="color: blue">
$ git config --global core.editor &lt;ваш_редактор&gt;
</code></pre>
        Для просмотра всех настроек глобального файла конфигурации выполните:
        <pre><code style="color: blue">
$ git config --global --list
...
</code></pre>
        для просмотра конкретного параметра -
        <pre><code style="color: blue">$ git config --global user.name
Ivan Ivanov
</code></pre>
        <p>В Windows часть (те, что задаются на этапе инсталляции Git ????) глобальных параметров хранится в файле <i>C:\Program Files\Git\etc\gitconfig</i>.</p>
        <p>Так как Git читает значение настроек из нескольких файлов, возможна ситуация когда Git использует не то значение что вы ожидали. В таком случае вы можете спросить Git откуда он берет этого значения.
        Git выведет имя файла, из которого значение для настройки было взято последним:

<pre><code style="color: blue">$ git config --show-origin core.editor
file:C:/Users/Konstantin/.gitconfig     nano</code></pre>
</p>

        <h3>Создание нового репозитория</h3>
        <p>Каталог, файлы которого отслеживает git, называется <i>рабочим каталогом</i> Git (work tree).
           Любой каталог можно превратить в рабочий создав для него <i>репозиторий</i> командой инициализации репозитория.</p>
        <p>Создадим у себя на компьютере пустую папку.</p>

        <pre><code style="color: blue">$ mkdir ~/project1</code></pre>

        <p>Создадим для неё репозиторий командой <i>git init</i>.</p>
        <pre><code style="color: blue">$ cd ~/project1
   
$ git init -b master
Initialized empty Git repository in ~/project1/.git/
(Инициализирован пустой репозиторий Git в ~/project1/.git/)</code></pre>
        
        <p>Команда инициализации создала в рабочем каталога подкаталог <i>.git/</i>, который и является «хранилищем репозитория» (или просто «репозиторием») СКВ Git.
        В нем будет храниться история всех изменений файлов, которые мы желаем отслеживать.
        <br>
        Замечение: у команды <i>git init</i> есть ещё один необязательный параметр <i>--separate-git-dir=путь</i>.
        Если он указан, то хранилище репозитория создается по указанному пути, а в текущем каталоге создается файл ".git", содержащий этот путь.</p>

        <p>Параметр -b, команды инициализации, присваивает имя начальной ветке, в нашем случае - <i>master</i> (о ветках смотри раздел «О ветвлении и ветках»).</p>

        <p>Посмотрим что находится в каталоге <i>.git/</i>.</p>
        <pre><code style="color: blue">$ ls -l .git/
итого 0
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 branches/
-rw-r--r-- 1 konstantin konstantin  92 2020-11-11 08:41 config
-rw-r--r-- 1 konstantin konstantin  73 2020-11-11 08:41 description
-rw-r--r-- 1 konstantin konstantin  23 2020-11-11 08:41 HEAD
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 hooks/
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 info/
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 objects/
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 refs/</code></pre>

        <p>В новом репозитории видим 3 файла и 4 подкаталога.</p>

        <p>Посмотрим содержимое каталога <i>.git/objects</i>.</p>

        <pre><code style="color: blue">$ ls -l .git/objects/
total 0</code></pre>

        <p>Сейчас он пустой.</p>
           
        <h3>Команда <i>git status</i></h3>

        <p>Для просмотра статуса рабочего каталога служит команда <i>git status</i>.
        Точнее говоря она сравнивает содержимое трех областей: 1)текущего состояния рабочего каталога, 2)индексированного состояния и 3)фиксированного состояния.
        (Об индексированном и фиксированном состояниях чуть после).</p>
        <pre><code style="color: blue">
$ git status
On branch master
(На ветке master)

No commits yet
(Ещё нет коммитов)

nothing to commit (create/copy files and use "git add" to track)
(ничего фиксировать (создайте/скопируйте файлы и запустите «git add», для отслеживания))
</code></pre>

        <p>"No commits yet (Еще нет коммитов)" - означеет, что область фиксации пустая,
        а "nothing to commit (ничего фиксировать" - что текущее состояние рабочего каталога и индексированное состояние не различаются (у данный момент они так-же пустые).</p>

        <p>Создадим в рабочем каталоге два файла (один в его корне, другой в подкаталоге d).</p>
        <pre><code style="color: blue">
$ echo -n "File1 v1" > file1

$ mkdir d

$ echo -n "File2 v1" > d/file2
</code></pre>

        <p>Посмотрим список файлов в рабочем каталоге.</p>
        
        <pre><code style="color: blue">
$ ls -lR
.:
итого 0
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:46 d/
-rw-r--r-- 1 konstantin konstantin   8 2020-11-11 08:46 file1

./d:
итого 0
-rw-r--r-- 1 konstantin konstantin 8 2020-11-11 08:46 file2
</code></pre>

        <p>Наш репозиторий никак не изменился.</p>

        <pre><code style="color: blue">
 ls -l .git
итого 0
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 branches/
-rw-r--r-- 1 konstantin konstantin  92 2020-11-11 08:41 config
-rw-r--r-- 1 konstantin konstantin  73 2020-11-11 08:41 description
-rw-r--r-- 1 konstantin konstantin  23 2020-11-11 08:41 HEAD
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 hooks/
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 info/
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 objects/
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 refs/
</code></pre>
        
        <p>А теперь какое сообщение выдает команда <i>git status</i>?</p>

        <pre><code style="color: blue">$ git status
On branch master
(На ветке master)

No commits yet
(Еще нет коммитов)

Untracked files:
(Неотслеживаемые файлы:)
  (используйте «git add <файл>…», чтобы добавить в то, что будет включено в коммит)
  ((use "git add <file>..." to include in what will be committed))
        d/
        file1

nothing added to commit but untracked files present (use "git add" to track)
(ничего не добавлено для фиксации, но есть неотслеживаемые файлы (используйте «git add», чтобы отслеживать их))</code></pre>


        <p>"No commits yet (Еще нет коммитов)" - по прежнему означеет, что область фиксации пустая,
        а "Untracked files: (Неотслеживаемые файлы:)" - что в рабочем каталоге есть файлы отсутствующие в индексированном состоянии (назаваются "неотслеживаемыми" файлами).
        <br>В нашем случае у нас в рабочем каталоге появились два неотслеживаемых файла.</p>

        <h3>Команда <i>git add</i></h3>

        <p>Git хранит историю не всех файлов рабочего каталога, а только тех, что отданы под версионный контроль.
            <br>Такие файлы называются <i>отслеживаемыми</i>.
            <br>Чтобы сделать файл или группу файлов отслеживаемыми, надо выполнить команду <i>git add</i>, передав ей в качестве параметров имена этих файлов.
            <br>Это добавит в индексируемую область информацию об этих файлах.
        </p>
            
        <pre><code style="color: #0000ff">$ git add file1 d/file2</code></pre>

        <p>С этого момента два добавленных файла стали отслеживаемыми.</p>

        <pre><code style="color: #0000ff">$ git status
On branch master
(На ветке master)

No commits yet
(Еще нет коммитов)

Changes to be committed:
(Изменения для фиксации:)
  (используйте «git rm --cached <файл>…», чтобы убрать из индекса)
        новый файл:    d/file2
        новый файл:    file1</code></pre>
        
        <p>Сообщение "Changes to be committed: (Изменения для фиксации:)" - означает, что в индексированной области есть изменения, по сравнению с областью фиксации (в нашем случае новые файлы).</p>

        <p>Посмотрим как операция <i>git add</i> отразилась на файлах репозитория <i>.git</i>.</p>
        
        <pre><code style="color: blue">
$ ls -l .git
итого 0
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 branches/
-rw-r--r-- 1 konstantin konstantin  92 2020-11-11 08:41 config
-rw-r--r-- 1 konstantin konstantin  73 2020-11-11 08:41 description
-rw-r--r-- 1 konstantin konstantin  23 2020-11-11 08:41 HEAD
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 hooks/
-rw-r--r-- 1 konstantin konstantin 176 2020-11-11 08:49 index
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 info/
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:49 objects/
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 refs/
</code></pre>
            
        <pre><code style="color: blue">
$ find .git/objects -type f
.git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f
</code></pre>

        <p>В каталоге <i>.git</i> команда  <i>git add</i> создала файл <i>index</i>, а в каталоге <i>.git/objects</i>
        <br>подкаталог с именем <i>47</i> и файлом <i>5190118d49d9905c1a82c6fd11dab9ab602cc4</i> и
        <br>подкаталог с именем <i>b2</i> с файлом <i>fb6cc242d8ca8d2623b8deb4a1a17349af6f2f</i>.</p>

        <h3>Об объектах Git</h3>

        <p>Различные команды, которые будут, которые мы будем выполнять, создают файлы в подкаталогах каталога <i>.git/objects/</i>.
        Эти файлы будем называть <i>объектами</i> git, а сам каталог - <i>базой объектов</i>.</p>

        <p>Объекты бывают нескольких типов.
        <br>В объектах в упакованном виде хранится специфичная для каждого вида информация и обозначение <i>типа объекта</i>.
        <br>Каждый объект имеет <i>идентификатор</i>, представляющий из себя 40-разрядное шестнадцатеричное число - это значение SHA-1 хеш-функции от содержимого объекта (упакованного/неупакованного???).
        <br>Имя подкаталога в котором сохраняется объект образовано первыми двумя символами идентификатора объекта.
        <br>Имя файла образовано оставшихся 38 символами идентификатора.</p>

        <h3>Объекты типа <i>blob</i></h3>

        <p>Т.о. команда <i>git add</i> создала два объекта с идентификаторами <i>475190118d49d9905c1a82c6fd11dab9ab602cc4</i> и <i>b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f</i>.
        <br>Объект с идентификаторами <i>475190118d49d9905c1a82c6fd11dab9ab602cc4</i> хранящийся в файле <i>objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4</i>,
        <br>и объект с идентификаторами <i>b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f</i> хранящийся в файле <i>objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f</i>.</p>

        <p>Типом объекта, создаваемый командой <i>git add</i>, является слово <i>blob</i> (от Binary Large Object).
        <br>В объектах <i>blob</i>-типа, как уже говорилось в упакованном виде, помимо обозначения типа, хранится содержимое отслеживаемых файлов (на момент выполнения команды <i>git add</i>).</p>

        <p>Тип любого объекта можно узнать командой <i>git cat-file -t &lt;id-object&gt;</i>.
        <br>Здесь, и в других командах, идентификатор объекта можно указывать не полностью; минимум четыре символа или более (когда неполный идентификатор не уникален).</p>

        <p>Убедимся, что созданные объекты имеют тип <i>blob</i>.</p>
        
        <pre><code style="color: blue">$ git cat-file -t 4751
blob

$ git cat-file -t b2fb
blob</code></pre>

        <p>Поскольку содержимое всех файлов-объектов, является текстовым файлом сжатым с помощью библиотеки zlib, 
        то любой объект можно распокавать утилитой <i>gzip</i> и посмотреть что в нем содержится.</p>

        <p>Посмотрим содержимое <i>blob</i>-объектов.</p>

        <pre><code style="color: blue">$ echo -en "\x1f\x8b\x08\x00\x00\x00\x00\x00" |cat - .git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4 |gzip -dc
blob 8File1 v1
gzip: stdin: unexpected end of file

$ echo -en "\x1f\x8b\x08\x00\x00\x00\x00\x00" |cat - .git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f |gzip -dc
blob 8File2 v1
gzip: stdin: unexpected end of file</code></pre>


        <p><i>blob</i>-объект состоит из трех частей:</p>
        <ul>
            <li>слово «blob» - тип объекта (все объекты начинаются с обозначения его типа???)</li>
            <li>целое число - размер исходного файла в байтах</li>
            <li>содержимого файла</li>
        </ul>

        <p>Просмотреть содержимое объектов можно проще.
        <br>Для этого есть опция <i>-p</i> команды <i>git cat-file</i>.
        <br>Почти всё содержимое всех объектов (кроме их типа и некоторой другой служебной информации) выводится командой <i>git cat-file -p &lt;id-object&gt;</i>.</p>
        
        <pre><code style="color: blue">$ git cat-file -p 4751
File1 v1

$ git cat-file -p b2fb
File2 v1</code></pre>
       
        <h4>О файле <i>index</i></h4>

        <p>Файл <i>index</i> хранит то самое индексируемое состояние (используемое в частности комаандой <i>git status</i>).
        <br>Часть (всё)???, что в нём находится можно посмотреть командой <i>git ls-files -s -t --debug</i>.</p>

        <pre><code style="color: blue">$ git ls-files -s -t --debug
H 100644 b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f 0     d/file2
  ctime: 1694516582:72510700
  mtime: 1694516582:72510700
  dev: 0        ino: 0
  uid: 0        gid: 0
  size: 8       flags: 0
H 100644 475190118d49d9905c1a82c6fd11dab9ab602cc4 0     file1
  ctime: 1694516570:912520200
  mtime: 1694516570:912520200
  dev: 0        ino: 0
  uid: 0        gid: 0
  size: 8       flags: 0</code></pre>

        <p>Есть ли в файле index ещё какая-то информация, которая не выводится этой командой????.</p>

        <p>Только необходимую нам сейчас информацию так:</p>

        <pre><code style="color: blue">$ git ls-files --stage
100644 b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f 0     d/file2
100644 475190118d49d9905c1a82c6fd11dab9ab602cc4 0     file1</code></pre>

        <p>Команда выводит список записей, по числу отслеживающих файлов.
         Каждая запись состоит из следующих полей:</p>

        <ul>
            <li>Первое поле: атрибуты файла /см. ниже/;</li>
            <li>Второе поле: идентификатор соответствующего <i>blob</i>-объекта.</li>
            <li>Третье поле: ???</li>
            <li>Четвертое поле: имя файла вместе с относительным путем.</li>
        </ul>

        <p>Что означают атрибуты файла 
              <ul>
                    <li>первая группа из трёх цифр - тип файла (040 - каталог, 100 - обычный файл, 120 - символическая ссылка, 160 - gitlink);</li>
                    <li>вторая группа из трёх - права доступа для владельца файла, для группы владельца и для остальных пользователей записанные как комбинация цифр 4, 2 и 1 (4 - право на чтение, 2 - право на запись, 1 - право на выполнение).</li>
              </ul>
        </p>

        <p>Поля <i>ctime</i> и <i>mtime</i> в "полном" выводе это соответственно время создания и время модификации файла.</p>

        <p>На основании информации содержащийся в индексе, а не фактического содержания рабочего каталога будет в дальнейшем фиксироваться информация о состояний рабочего каталога.</p>

        <h3>О файле <i>.gitignore</i></h3>

        <p>В большинстве проектов есть файлы или целые директории, которые мы не хотим отслеживать.</p>
        <p>Их имена (или шаблоны под которые они подпадают) можно перегислить в файле <i>.gitignore</i>.</p>
        <p>Тогда такие файлы не будут отдаваться под версионный контроль командами <i>git add .</i> или <i>git add -A</i>.</p>
        <p>Даже при явном указании имени файла будет выдаваться сообщение об ошибке, например:</p>

        <pre><code style="color: blue">$ git add file.log
The following paths are ignored by one of your .gitignore files:
file.log
hint: Use -f if you really want to add them.
hint: Turn this message off by running
hint: "git config advice.addIgnoredFile false"</code></pre>
        
        <h3>Локальное имя пользователя и email</h3>

        <p>При первоначальной конфигурации Git мы указывали имя пользователя и его email, которые сохранили в глобальном конфигурационном файле.
        <br>Однако для разных репозиториев можно указать разные настройки, хранящиеся в локальном конфигурационном файле репозитория <i>.git/config</i>.
        <br>С этим учебным репозиторием мы будем работать под именем Ivan Ivanov &lt;ivan@localhost&gt;.</p>

        <pre><code style="color: blue">$ git config user.name "Ivan Ivanov"
$ git config user.email "ivan@localhost"</code></pre>

        <p>Команда <i>git config</i> без параметра <i>--global</i> заносит имя, фамилию и почту в локальный конфигурационный файл,
           относящийся только к этому репозиторию.</p>

        <pre><code style="color: blue">$ cat .git/config
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[user]
        name = Ivan Ivanov
        email = ivan@localhost</code></pre>

        <h3>Фиксация состояний рабочего каталога. Команда <i>git commit</i></h3>

        <p>Объектов типа <i>blob</i>, которые создаются командай <i>git add</i>, недостаточно для восстановления состояний рабочего каталога.
        Эти объекты хранят содержимое файлов, но там нет информации о именах файлов, других их атрибутах, а также путей, по которым они хранились.</p>

        <p>Эта, и другая информация, необходимая для восстановления состояния рабочего каталога в будущем, подлежат <i>фиксации</i> в репозитории при помощи команды <i>git commit</i>.</p>

       <p>Команда <i>git commit</i> создает объекты типа commit и tree.
         <br>Идентификаторы этих объектов (<i>&lt;id-commit&gt;</i> и <i>&lt;id-tree&gt;</i>), в отличие от объектов типа <i>blob</i>, зависят от даты и времени создания этих объектов,
         т.к. это время хранится в самих этих объектах, а идентификаторы объектов зависят от их содержимого.
         <br>Для учебных примеров это не удобно, поэтому в учебных примерах мы всякий раз, перед выполнением команды <i>git commit</i>,
         будем устанавливать определенную дату и время в двух переменных окружения GIT_AUTHOR_DATE и GIT_COMMITTER_DATE.
         Когда эти пепеменные установлены, то команда <i>git commit</i> берет время из этих переменных.
         В результате идентификаторы commit и tree объектов и время в них сохраненное будут одинаково у всех, кто повторит эти примеры.</p>
        <p>В реальной работе, разумеется, переменные окружения GIT_AUTHOR_DATE и GIT_COMMITTER_DATE устанавливать не надо.</p>


        <p>Установим значения переменных окружения и зафиксируем состояние нашего рабочего каталога.</p>
        <pre><code style="color: blue">$ export GIT_AUTHOR_DATE="2000-01-01 00:01"

$ export GIT_COMMITTER_DATE="2000-01-01 00:01"

$ git commit -m "comment #1"
[master (корневой коммит) 69701b6] comment #1
 2 files changed, 2 insertions(+)
 create mode 100644 d/file2
 create mode 100644 file1</code></pre>
 
        <p>После опции <i>-m</i> в команде необходимо оставлять информацию о характете изменениях зафиксированных этим коммитом.
        <br>В реальной работе надо конечно оставлять более информативные сообщения чем в наших примерах.</p>
        
        <p>Число <i>69701b6</i>, в первой строке выведенной командой, показывает первые семь цифр идентификатора <i>&lt;id-commit&gt;</i> созданного commit-объекта.
        <br>Примечание: Если вместо <i>69701b6</i> вы видите другой <i>&lt;id-commit&gt;</i>, то это значит, что вы не установили (или неправильно установили)
        переменные окружения GIT_AUTHOR_DATE или GIT_COMMITTER_DATE,
        либо значение параметра name отличное от «Ivan Ivanov»,
        либо значение параметра email отличное от «ivan@localhost»,
        либо значение параметра -b команды <i>git commit</i> отличное от «comment #1».</p>






        <p>Полный &lt;id-commit&gt;, а также кто и когда зафиксировал новое состояние, и какое сообщение (комментарий) он оставил, можно посмотреть в <i>истории коммитов</i>, командой <i>git log</i>.</p>

        <pre><code style="color: blue">$ git log
commit 69701b6e701d429882c083e98e1ecf195868b38c (HEAD -> master)
Author: Ivan Ivanov <ivan@localhost>
Date:   Sat Jan 1 00:01:00 2000 +0200

    comment #1</code></pre>








        <p>Посмотрим текущее состояние репозитория.</p>
        <pre><code style="color: blue">$ git status
On branch master
(На ветке master)
nothing to commit, working tree clean
(ничего фиксировать, нет изменений в рабочем каталоге)</code></pre>

        <p>Собщене "nothing to commit (ничего фиксировать)" - означает, что индексная область тождественна фиксированной области, а "working tree clean (нет изменений в рабочем каталоге)",
        что область рабочего каталога тождественна индексной области?????</p>
            
        <p>Посмотрим как операция <i>git commit</i> отразилась на файлах репозитория.</p>
            
        <pre><code style="color: blue">$ ls -l .git/
итого 0
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 branches/
-rw-r--r-- 1 konstantin konstantin  11 2020-11-11 09:44 COMMIT_EDITMSG <span style="color: red"># новый файл</span>
-rw-r--r-- 1 konstantin konstantin 143 2020-11-11 09:43 config
-rw-r--r-- 1 konstantin konstantin  73 2020-11-11 08:41 description
-rw-r--r-- 1 konstantin konstantin  23 2020-11-11 08:41 HEAD
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 hooks/
-rw-r--r-- 1 konstantin konstantin 235 2020-11-11 09:44 index <span style="color: red"># изменились размер и время модификации</span>
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 info/
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 09:44 logs/ <span style="color: red"># изменилось время и содержимое каталога (его содержимым пока интересоваться не будем)</span>
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 09:44 objects/ <span style="color: red"># изменилось время и содержимое каталога</span>
drwxr-xr-x 1 konstantin konstantin 512 2020-11-11 08:41 refs/</code></pre>

        <p>Видим что в репозитории появились новые файлы, в т.ч. новые объекты.</p>
            
        <pre><code style="color: blue">$ find .git/objects -type f
.git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4
.git/objects/69/701b6e701d429882c083e98e1ecf195868b38c <span style="color: red"># новый объект</span>
.git/objects/6c/59b709d4abf607ab16a03b22db93412fe437a4 <span style="color: red"># новый объект</span>
.git/objects/96/6e9a46c8df9aa3b2108864be07abe7b5d1d0f9 <span style="color: red"># новый объект</span>
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f</code></pre>

        <p>Есть три новых объекта. Посмотрим их типы:</p>

        <pre><code style="color: blue">$ git cat-file -t 6970
commit

$ git cat-file -t 6c59
tree

$ git cat-file -t 966e
tree
</code></pre>

        <p>Видим что команда <i>git commit</i> создала объекты двух новых типов: <i>comment</i> и <i>tree</i>.</p>

        <p>Посмотрим что хранят новые файлы</p>


        <pre><code style="color: blue">$ cat .git/COMMIT_EDITMSG
comment #1</code></pre>

<p>Файл <i>.git/COMMIT_EDITMSG</i> хранит сообщение созданного commit-объекта.</p>

        <pre><code style="color: blue">$ cat .git/refs/heads/master
69701b6e701d429882c083e98e1ecf195868b38c</code></pre>

<p>Файл <i>.git/refs/heads/master</i> хранит идентификатор созданного commit-объекта.</p>

        <h5>Указатели</h5>

        <p>Все файла создаваемые в процессе работы в каталоге <i>.git/refs/heads/</i> хранят идентификаторы каких-либо commit-объектов. Такие файлы называются <i>указателями</i>.</p>

        <p>После первого коммита появляется первый указатель с именем указанным при инициализации репозитория.
        В нашем случае это <i>master</i>.</p>

        <p>В последствии в каталоге <i>.git/refs/heads/</i> могут создаваться другие указатели.
        <br>Один из них является <i>текущим</i> указателем.
        <br>Его имя хранится в файле <i>.git/HEAD</i>.</p>

        <p>Для просмотра всех существующих указателей имеется команда <i>git branch</i> (без параметров) :</p>
        <pre><code style="color: blue">$ git branch
* master</code></pre>

        <p>Текущий коммит в списке выделяется звездочкой.</p>

        <p>Позже мы рассмотрим все команды изменяющие id текущего коммита;
        а пока запомним, что команды <i>git commit</i> делает текущим созданный этой командой коммит; при этом указатель коммита остается прежним.</p>

        <p>Идентификатор коммита, хранящийся в указателе с именем &lt;name&gt; можно посмотреть командой <i>git rev-parse &lt;name&gt;</i>, например:</p>

        <pre><code style="color: blue">$ git rev-parse master
69701b6e701d429882c083e98e1ecf195868b38c</code></pre>

        <h5>Объекты <i>tree</i></h5>

        <p>Посмотрим содержимое объектов типа <i>tree</i>:</p>



        <pre><code style="color: blue">$ echo -en "\x1f\x8b\x08\x00\x00\x00\x00\x00" |cat - .git/objects/6c/59b709d4abf607ab16a03b22db93412fe437a4 |gzip -dc
tree 6140000 d▒n▒F▒ߚ▒▒▒d▒▒▒▒▒▒100644 file1GQ▒▒Iِ\▒▒▒ڹ▒`,▒
gzip: stdin: unexpected end of file

$ echo -en "\x1f\x8b\x08\x00\x00\x00\x00\x00" |cat - .git/objects/96/6e9a46c8df9aa3b2108864be07abe7b5d1d0f9 |gzip -dc
tree 33100644 file2▒▒l▒B▒ʍ&#▒޴▒▒sI▒o/
gzip: stdin: unexpected end of file</code></pre>

        <p>Что-то не то ???????????????????????????????????????</p>





        <p>Посмотрим содержимое объектов типа <i>tree</i> так:</p>

        <pre><code style="color: blue">$ git cat-file -p 6c59
040000 tree 966e9a46c8df9aa3b2108864be07abe7b5d1d0f9    d
100644 blob 475190118d49d9905c1a82c6fd11dab9ab602cc4    file1

$ git cat-file -p 966e
100644 blob b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f    file2</code></pre>

        <p>Дерево хранит список записей файлов и каталогов, а также соответствующих им объектов.
            Каждая запись в дереве состоит из четырех полей:!</p>
        <ul>
            <li>Первое поле: атрибуты файла или каталога аналогично тому, как в индексе;</li>
            <li>Второе поле: тип объекта, либо <i>blob</i>, либо <i>tree</i>.</li>
            <li>Третье поле: идентификатор объекта.</li>
            <li>Четвертое поле: имя файла, если тип объекта <i>blob</i>, или имя директории, если тип объекта <i>tree</i>.</li>
        </ul>

        <p>Дерево git-а аналогично каталогу файловой системы, а blob аналогичен inode.
            Деревья образуют иерархию, аналогичную иерархии каталогов и файлов.</p>
        <p>Деревья объединяют blob-объекты и деревья в иерархии, аналогичные каталогам файловой системе.</p>

        <p>Деревья создаются командой <i>git commit</i> на основании информации содержащийся в индексе, а не фактического содержания рабочего каталога в момент выполнения команды!
        Это очень важно для понимания работы git.</p>






        <h5>Объекты <i>comment</i></h5>

        <p>Посмотрим содержимое объекта типа <i>comment</i>:</p>
            
        <pre><code style="color: blue">$ echo -en "\x1f\x8b\x08\x00\x00\x00\x00\x00" |cat - .git/objects/69/701b6e701d429882c083e98e1ecf195868b38c |gzip -dc
commit 165tree 6c59b709d4abf607ab16a03b22db93412fe437a4
author Ivan Ivanov <ivan@localhost> 946677660 +0200
committer Ivan Ivanov <ivan@localhost> 946677660 +0200

comment #1

gzip: stdin: unexpected end of file</code></pre>

        <p>Более простой способ посмотреть содержимое коммита - воспользоваться командой <i>cat-file</i> с ключем <i>--commit</i> или <i>-p</i>.
        Она выведет тоже содержимое что и предыдущая команда, кроме поля <i>commit &lt;число&gt;</i>).

        <pre><code style="color: blue">$ git cat-file -p 6970
tree 6c59b709d4abf607ab16a03b22db93412fe437a4
author Ivan Ivanov <ivan@localhost> 946677660 +0200
committer Ivan Ivanov <ivan@localhost> 946677660 +0200

comment #1
</code></pre>

        <p>Созданный <i>comment</i>-объект содержит следующую информацию:</p>
        <ul>
            <li>после слова «commit» - число (что означает???);</li>
            <li>после слова «tree» - id объекта типа дерево, который хранит иерархию рабочего каталога;</li>
            <li>после слова «parent» - id родителя (есть у всех коммитов, кроме первого) /см. ниже/;</li>
            <li>после слова «author» - имя человека, предложившего ??? изменения в проект, затем его email, затем время (чего???) /см. ниже/;</li>
            <li>после слова «committer» - имя человека, зафиксировавший изменение в репозитории (т.е. выполнивший команду git commit), затем его email, затем время внесения изменений в репозиторий /см. ниже/;</li>
            <li>пустая строка</li>
            <li>сообщение поясняющее внесенные изменения из параметра </i>-b</i> команды <i>comment</i>.</li>
        </ul>

        <p>Что такое родитель/родители коммита?
        Это другой(ие), уже существующий(ие) в системе,<i>comment</i>-объект(ы), на основе которого(рых) строится данный коммит объект.
        <br>Стандартная является ситуация когда у каждого коммита один родитель.
        У первого коммита родителя нет.
        У некоторых коммитов может быть несколько родителей, тогда ссылка на каждого из родителей выводится на отдельной строчке.
        <br><i>Comment</i>-объекты могут создаются не только командой <i>git commit</i>.
        Но это основная команда создающая коммиты.
        Она всегда создает коммит только с одним родителем, которым является <i>текущий коммит</i>.</p>

        <p>Если коммит «B» имеет родителем коммит «A» (A ← B), то «B» для «A» является потомком (child).</p>
        <p>Если в репозитории есть коммиты которые являются предками для нескольких коммитов, то говорят о <i>ветвлении</i> коммитов.
        <br>Если в репозитории есть коммиты у которых более одного предка, то говорят о <i>слиянии</i> коммитов.
        <br>Репозитории без ветвлений и слияний называется <i>линейными</i>.</p>

        <p>Поля <i>&lt;committer name&gt;</i> <i>&lt;committer email&gt;</i> заполняются на основании переменных окружения «GIT_COMMITTER_NAME», «GIT_COMMITTER_EMAIL».
            Если эти переменные окружения не установлены, то значения берутся из локального файла конфигурации, а если они в нем не установлены то из глобального файла конфигурации.</p>

        <p>Поля <i>&lt;author name&gt;</i> <i>&lt;author email&gt;</i> заполняются на основании переменных окружения «GIT_AUTHOR_NAME», «GIT_AUTHOR_EMAIL».
        Если эти переменные окружения не установлены, то <i>&lt;author name&gt;</i> <i>&lt;author email&gt;</i> устанавливаются аналогичными <i>&lt;committer name&gt;</i> <i>&lt;committer email&gt;</i>.
        <br>При помощи параметров --author=<i>"имя &lt;email&gt;"</i> команды <i>git commit</i> эти значения можно переопределить.</p>
 
        <p>Как правило значения <i>&lt;committer data&gt;</i> и <i>&lt;author data&gt;</i> устанавливаются в соответствии с текущим временем.
        <br>Однако если установлены переменные окружения «GIT_AUTHOR_DATE» и «GIT_COMMITTER_DATE», то <i>&lt;committer data&gt;</i> и <i>&lt;author data&gt;</i> устанавливается на основании значений этих переменных окружения.
        <br>При помощи параметра  --date=<i>"время"</i> команды <i>git commit</i> можно переопределить значения <i>&lt;author data&gt;</i>.</p>


        <p>Зачем в учебных примерах может понадобиться устанавливать переменные окружения «GIT_AUTHOR_DATE» и «GIT_COMMITTER_DATE»?
        <br>Наличие в объекте commit имени автора и коммитера, а также времени создания и фиксации изменений приводит к тому, что идентификаторы создаваемых коммитов зависят от этих значений.
        И при повторении примеров идентификаторы коммитов будут получаться иными.
        Иногда это неудобно. В таких случаях автора и коммитера мы будем устанавливать в локальном файле конфигурации:</p>
        <pre><code style="color: blue">git config user.name "Ivan Ivanov"
git config user.email "ivan@localhost"</code></pre>
        а время задавать в командной строке:
        <pre><code style="color: blue">$ export GIT_AUTHOR_DATE="2000-01-01 00:00:00"
$ export GIT_COMMITTER_DATE="2000-01-01 00:00:00"</code></pre>

        <p>Что ещё изменилось в результате работы <i>git commit</i>?
        <br>Изменилось время модификации файла <i>index</i> и его размер.
        <br>Но информация выводимая командой <i>git ls-files --stage -t</i> не изменилась</i>.</p>


        <pre><code style="color: blue">$ git ls-files --stage -t
H 100644 b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f 0     d/file2
H 100644 475190118d49d9905c1a82c6fd11dab9ab602cc4 0     file1</code></pre>

        <p>Что-то индекс хранит ещё!!!!. (в редакторе видно что изменился конец файла, а начало осталось!!!)</p>







        <p>Дерево git-а аналогично каталогу файловой системы, а blob аналогичен inode.
        Деревья образуют иерархию, аналогичную иерархии каталогов и файлов.</p>
        <p>Деревья объединяют blob-объекты и деревья в иерархии, аналогичные каталогам файловой системе.</p>

        <p><i>Снимок (snapshot) системы</i> - это дерево рабочего каталога вместе со всеми объектами на которые оно по цепочке ссылается.</p>
        <p>Мы имеем первый снимок нашей системы</p>

        <pre><code style="color: blue">
6c59 (раб.катал.) ---+--&gt; 4751 (файл «file1»)
                     |
                     +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)</code></pre>
        <p>Что следует из того, что идентификаторы блобов, деревьев, как и всех остальных объектов, являются хешем их содержимого?
        Если у двух объектов-деревьев одинаковые идентификаторы,
        это означает что внутренности этих деревьев совпадают!
        А так как внутренности деревьев - это ссылки на объекты, то это означает что два дерева ссылаются на одни и те же объекты. Которые в свою очередь тоже могут быть деревьями или блобами.
        Таким образом идентификатор дерева на самом деле идентифицирует не только "файлы в одной директории", но и все файлы во всех поддиректориях этой директории - одно имя для всей иерархии!</p>
        <p>Это свойство позволяет git-у очень быстро производить сравнение
        деревьев со сколь угодно сложной иерархией, уровнями вложенности и т.д.
        без чтения собственно содержимого - blob-ов или tree.</p>












        <h4>Продолжим рассмотрение нашего примера</h4>

        <p>Создадим в рабочем каталоге еще один файл.</p>
            
        <pre><code style="color: blue">
$ echo -n "File3 v1" > file3
</code></pre>
            
        <p>Посмотрим новый статус рабочего каталога.</p>
            
        <pre><code style="color: blue">$ git status
На ветке master
Неотслеживаемые файлы:
  (используйте «git add <файл>…», чтобы добавить в то, что будет включено в коммит)
        file3

ничего не добавлено для фиксации, но есть неотслеживаемые файлы (используйте «git add», чтобы отслеживать их)</code></pre>

        <p>....что это значит???....</p>

        <p>Под заголовком «Неотслеживаемые файлы (Untracked files)» команда вывела добавленный нами файл file3.
        <br>Он пока является неотслеживаемым.
        <br>Если сейчас попробовать зафиксировать новое состояние репозитория, то ничего не произойдет.</p>
        <pre><code style="color: blue">$ git commit -m "comment #2"
На ветке master
Неотслеживаемые файлы:
  (используйте «git add <файл>…», чтобы добавить в то, что будет включено в коммит)
        file3

ничего не добавлено для фиксации, но есть неотслеживаемые файлы (используйте «git add», чтобы отслеживать их)</code></pre>
        <p>
            Сделаем файл file3 отслеживаемым и посмотрим на новый статус репозитория
        <pre><code style="color: blue">
$ git add file3

$ git status
На ветке master
Изменения для фиксации:
  (use "git restore --staged <file>..." to unstage)
        новый файл:    file3
</code></pre>

        <p>....что это значит???....</p>

        <p>Команда вывела файл file3 уже под заголовком «Изменения, которые будут включены в коммит (Changes to be committed)». Сейчас файл file3 подготовлен (stage) для фиксации.</p>




        <p>********** добавить вывод команды <i>git ls-files --stage</i> ************<p>

















        <p>Выполним фиксацию

        <pre><code style="color: blue">$ export GIT_AUTHOR_DATE="2000-01-01 00:02"

$ export GIT_COMMITTER_DATE="2000-01-01 00:02"

$ git commit -m "comment #2"
[master 03c1a7f] comment #2
 1 file changed, 1 insertion(+)
 create mode 100644 file3</code></pre>

        <p>и снова посмотрим историю.

        <pre><code style="color: blue">$ git log
commit 03c1a7f12800978dde0b8cd6383595e7007d0098 (HEAD -> master)
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:02:00 2000 +0200

    comment #2

commit 69701b6e701d429882c083e98e1ecf195868b38c
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:01:00 2000 +0200

    comment #1

$ git status
On branch master
nothing to commit, working tree clean</code></pre>

        <p>....что это значит???....</p>

        <p>У нас «чистый» репозиторий с двумя зафиксированными изменениями.</p>















        <p>Что поменялось?</p>

        <pre><code style="color: blue">
$ ls -l .git/index
-rw-r--r-- 1 Konstantin 197121 307 июл 15 14:53 .git/index

$ git ls-files --stage
100644 b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f 0       d/file2
100644 475190118d49d9905c1a82c6fd11dab9ab602cc4 0       file1
100644 ad2a32f77c6c6eac140b94619e332c89d1319b6b 0       file3

$ find .git/objects -type f
.git/objects/03/c1a7f12800978dde0b8cd6383595e7007d0098 <span style="color: red"># новый объект</span>
.git/objects/27/63fac853abca428edd5c2a1b48ef5d212ff99a <span style="color: red"># новый объект</span>
.git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4
.git/objects/69/701b6e701d429882c083e98e1ecf195868b38c
.git/objects/6c/59b709d4abf607ab16a03b22db93412fe437a4
.git/objects/96/6e9a46c8df9aa3b2108864be07abe7b5d1d0f9
.git/objects/ad/2a32f77c6c6eac140b94619e332c89d1319b6b
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f

$ git cat-file -t 03c1
commit

$ git cat-file -t 2763
tree

$ git cat-file -p 03c1
tree 2763fac853abca428edd5c2a1b48ef5d212ff99a
parent 69701b6e701d429882c083e98e1ecf195868b38c
author Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200
committer Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200

comment #2

$ git cat-file -p 2763
040000 tree 966e9a46c8df9aa3b2108864be07abe7b5d1d0f9    d
100644 blob 475190118d49d9905c1a82c6fd11dab9ab602cc4    file1
100644 blob ad2a32f77c6c6eac140b94619e332c89d1319b6b    file3
</code></pre>
        Снова изменился индекс (однако вывод команды <i>git ls-files --stage</i> не изменился).
        <pre><code style="color: blue">
$ git branch
* master
</code></pre>
        <p>
            Текущий указатель по прежнему <i>master</i>
        <pre><code style="color: blue">
$ git rev-parse master
03c1a7f12800978dde0b8cd6383595e7007d0098
</code></pre>
        Текущий коммит сменился на <i>03c1a7f12800978dde0b8cd6383595e7007d0098</i>
        <pre><code style="color: blue">
$ git cat-file -p 03c1
tree 2763fac853abca428edd5c2a1b48ef5d212ff99a
parent 69701b6e701d429882c083e98e1ecf195868b38c
author Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200
committer Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200

comment #2
</code></pre>
        Новый коммит указывает на новое дерево.
        Родителем нового коммита является наш первый коммит
        <p>
            Новый снимок системы
        <pre><code style="color: blue">
2763 ---+--&gt; 4751 (файл «file1»)
        |
        +--&gt; ad2a (файл «file3»)
        |
        +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>


























        <h2>****</h2>


        <p>Изменим содержимое файла file3, добавив еще одну строку. И смотрим статус.</p>

        <pre><code style="color: blue">$ echo -ne "\nSecond line (v2)" >> file1

$ git status
На ветке master
Изменения, которые не в индексе для коммита:
  (используйте «git add <файл>…», чтобы добавить файл в индекс)
  (use "git restore <file>..." to discard changes in working directory)
        изменено:      file1

нет изменений добавленных для коммита
(используйте «git add» и/или «git commit -a»)</code></pre>

        Файл file1 выведен уже под заголовком «Изменения, которые не в индексе для коммита (Changes not staged for commit)». Он модифицирован (Modified).
        <br>
            Модифицированные файла, как и новые, перед фиксацией тоже надо подготовить.
        <p>Подготовим для фиксации новую версию файла file1.</p>
        <pre><code style="color: blue">$ git add file1

$ git status
На ветке master
Изменения для фиксации:
  (use "git restore --staged <file>..." to unstage)
        изменено:      file1</code></pre>

        <p>....что это значит???....</p>





        <pre><code style="color: blue">$ git ls-files --stage
100644 b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f 0       d/file2
100644 1d5260cb0591933230fdaaa8035a94b8e393ea20 0       file1 <span style="color: red"># поменялся идентификатор</span>
100644 ad2a32f77c6c6eac140b94619e332c89d1319b6b 0       file3

$ find .git/objects -type f
.git/objects/03/c1a7f12800978dde0b8cd6383595e7007d0098
.git/objects/1d/5260cb0591933230fdaaa8035a94b8e393ea20 <span style="color: red"># новый объект</span>
.git/objects/27/63fac853abca428edd5c2a1b48ef5d212ff99a
.git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4
.git/objects/69/701b6e701d429882c083e98e1ecf195868b38c
.git/objects/6c/59b709d4abf607ab16a03b22db93412fe437a4
.git/objects/96/6e9a46c8df9aa3b2108864be07abe7b5d1d0f9
.git/objects/ad/2a32f77c6c6eac140b94619e332c89d1319b6b
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f
</code></pre>
        <p>Замечание: Когда команда <i>git add</i> выполняется с модифицированным файлом, она не добавляет, а изменяет уже имеющуюся запись в индексе.</p>


        <p>В папке <i>object</i> появился ещё один <i>blob</i>-объект <i>1d5260cb0591933230fdaaa8035a94b8e393ea20</i> с новым содержимым файла <i>file1</i></p>




        <h2>****</h2>




        <p>Подготовка выполнена. Можно фиксировать новое состояние.</p>
        <pre><code style="color: blue">
$ export GIT_AUTHOR_DATE="2000-01-01 00:03"

$ export GIT_COMMITTER_DATE="2000-01-01 00:03"

$ git commit -m "comment #3"
[master 344b36b] comment #3
 1 file changed, 2 insertions(+), 1 deletion(-)

</code></pre>

        <p>Смотрим историю комментов</p>

        <pre><code style="color: blue">
$ git log
commit 344b36ba2aeb489f97a4928816eeeefb30ddfac2 (HEAD -> master)
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:03:00 2000 +0200

    comment #3

commit 03c1a7f12800978dde0b8cd6383595e7007d0098
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:02:00 2000 +0200

    comment #2

commit 69701b6e701d429882c083e98e1ecf195868b38c
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:01:00 2000 +0200

    comment #1

</code></pre>

        <p>и статус файлов.</p>

        <pre><code style="color: blue">
$ git status
На ветке master
ничего фиксировать, нет изменений в рабочем каталоге
</code></pre>

        <p>И снова у нас «чистый директорий».</p>


        <h2>****</h2>




        <p>Что поменялось?</p>

        <pre><code style="color: blue">
$ find .git/objects -type f
.git/objects/03/c1a7f12800978dde0b8cd6383595e7007d0098
.git/objects/1d/5260cb0591933230fdaaa8035a94b8e393ea20
.git/objects/27/63fac853abca428edd5c2a1b48ef5d212ff99a
.git/objects/34/4b36ba2aeb489f97a4928816eeeefb30ddfac2 <span style="color: red"># новый объект</span>
.git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4
.git/objects/69/701b6e701d429882c083e98e1ecf195868b38c
.git/objects/6c/59b709d4abf607ab16a03b22db93412fe437a4
.git/objects/96/6e9a46c8df9aa3b2108864be07abe7b5d1d0f9
.git/objects/ad/2a32f77c6c6eac140b94619e332c89d1319b6b
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f
.git/objects/b8/92ad555729a5275bb9ba81158e2a708da84b11 <span style="color: red"># новый объект</span>

$ git cat-file -t 03c1
commit

$ git cat-file -t b892
tree

$ git cat-file -p 03c1
tree 2763fac853abca428edd5c2a1b48ef5d212ff99a
parent 69701b6e701d429882c083e98e1ecf195868b38c
author Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200
committer Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200

comment #2

$ git cat-file -p b892
040000 tree 966e9a46c8df9aa3b2108864be07abe7b5d1d0f9    d
100644 blob 1d5260cb0591933230fdaaa8035a94b8e393ea20    file1
100644 blob ad2a32f77c6c6eac140b94619e332c89d1319b6b    file3
</code></pre>
        Появилось новое дерево и новый коммит.
        <p>
            Вот новый снимок системы
        <pre><code style="color: blue">
b892 (раб.катал.) ---+--&gt; 1d52 (файл «file1» v2)
                     |
                     +--&gt; ad2a (файл «file3»)
                     |
                     +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
        А так выгладит вся история нашего рабочего каталога.
        <pre><code style="color: blue">
344b (commit #3) --&gt; b892 (раб.катал.) ---+--&gt; 1d52 (файл «file1» v2)
|                                         |
|                                         +--&gt; ad2a (файл «file3»)
|                                         |
|                                         +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
V
03c1 (commit #2) --&gt; 2763 (раб.катал.) ---+--&gt; 4751 (файл «file1»)
|                                         |
|                                         +--&gt; ad2a (файл «file3»)
|                                         |
|                                         +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
V
6970 (commit #1) --&gt; 6c59 (раб.катал.) ---+--&gt; 4751 (файл «file1»)
                                          |
                                          +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
        <p>
            Таже история выдаваемая командой <i>git log --graph</i>
        <pre><code style="color: blue">
$ git log --graph
* commit 344b36ba2aeb489f97a4928816eeeefb30ddfac2 (HEAD -> master)
| Author: Ivan Ivanov &lt;ivan@localhost&gt;
| Date:   Sat Jan 1 00:03:00 2000 +0200
|
|     comment #3
|
* commit 03c1a7f12800978dde0b8cd6383595e7007d0098
| Author: Ivan Ivanov &lt;ivan@localhost&gt;
| Date:   Sat Jan 1 00:02:00 2000 +0200
|
|     comment #2
|
* commit 69701b6e701d429882c083e98e1ecf195868b38c
  Author: Ivan Ivanov &lt;ivan@localhost&gt;
  Date:   Sat Jan 1 00:01:00 2000 +0200

      comment #1
</code></pre>










        <p>Команда <i>git log</i> имеет множество параметров. Удобный вывод, которым мы будем пользоваться в дальнейшем, можно получить с такими параметрами:</p>

        <pre><code style="color: blue">
$ git log --pretty=format:'%h %ad - %s%d [%an]' --graph --date=format:'%Y-%m-%d %H:%M %z'
* 344b36b 2000-01-01 00:03 +0200 - comment #3 (HEAD -> master) [Ivan Ivanov]
* 03c1a7f 2000-01-01 00:02 +0200 - comment #2 [Ivan Ivanov]
* 69701b6 2000-01-01 00:01 +0200 - comment #1 [Ivan Ivanov]
</code></pre>
        
        <h3>Восстановление предыдущих состояний рабочего каталога. Команда <i>git checkout</i></h3>

        <p>
            Откатить состояние рабочего каталога Git на состояние зафиксированное коммитом с &lt;id&gt; равным &lt;id-commit&gt; можно командой <i>git checkout &lt;id-commit&gt;</i>
        </p>

        <p>Откатимся на <i>03c1a7</i> (comment #2).</p>

        <pre><code style="color: blue">
$ git checkout 03c1
Note: switching to '03c1'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD сейчас на 03c1a7f comment #2
</code></pre>
        <p>Проверьте состояние рабочего каталога. [проверить содеримое каталогов и файлов...]</p>

        <p>Вернемся на состояние зафиксированное последним коммитом (на коммит на который указывает указатель <i>master</i>).</p>
        <pre><code style="color: blue">
$ git checkout master
Предыдущая позиция HEAD была 03c1a7f comment #2
Переключено на ветку «master»
</code></pre>












        <h3>Как работает команда <i>git checkout</i></h3>

        <p>
            Мы уже говорили что откатить состояние рабочего каталога на состояние соответствующее &lt;id-commit&gt; можно командой <i>git checkout &lt;id-commit&gt;</i>
        <pre><code style="color: blue">
$ git checkout 03c1
Note: checking out '03c1'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch-name&gt;

HEAD is now at 03c1a7f comment #2
</code></pre>
        Проверьте состояние рабочего каталога
        <p>
            Мы говорили, что файле <i>.git/HEAD</i> хранит имя текущего указателя, который ссылается на текущий коммит.
            Что там сейчас?
        <pre><code style="color: blue">
$ cat .git/HEAD
03c1a7f12800978dde0b8cd6383595e7007d0098
</code></pre>
        Там вместо имени текущего указателя там находится идентификатор текущего коммита, который мы назначили командой <i>git checkout</i>
        <p>
            Продвинемся ещё дольше в историю
        <pre><code style="color: blue">
$ git checkout 6970
Previous HEAD position was 03c1a7f comment #2
HEAD is now at 69701b6 comment #1
</code></pre>
        Снова проверьте состояние рабочего каталога и содержимое <i>.git/HEAD</i>.
        <pre><code style="color: blue">
$ cat .git/HEAD
69701b6e701d429882c083e98e1ecf195868b38c
</code></pre>
        Вернем к последнему состоянию
        <pre><code style="color: blue">
$ git checkout master
Previous HEAD position was 69701b6 comment #1
Switched to branch 'master'

$ cat .git/HEAD
ref: refs/heads/master
</code></pre>
        И снова у нас последнее сохраненное состояние,
        а в <i>.git/HEAD</i> указатель <i>master</i>

        <h3>О ветвлении и ветках</h3>

        <p>Работая над проектом вам может потребоваться отклониться от основной линии разработки и продолжить работу
            независимо от нее, не вмешиваясь в основную линию.
            По завершении такой работа, как правило, нужно перенести наработки в основную линию.
            Такие действия, при работе с проектом, называются <i>ветвлением</i> <i>и слиянием</i>.
            Ветвление в любой СКВ можно организовать путем копирования всего проекта.
            Однако такой способ ветвления является долгим и затратным.
        </p>
        <p>
            В Git ветвление очень легковесно и операции создания ветки выполняется почти мгновенно.
            Git поощряет процесс работы, при котором ветвление и слияние выполняется часто, даже по несколько раз в день.
            Понимание и владение этой функциональностью дает вам уникальный и мощный инструмент.
        </p>
        <p>
            В документации по git постоянно используется термин <i>ветка</i>.
            Однако в разных местах в этот термин вкладывается разный смысл.
            То это некая последовательность коммитов, то указатель на коммит.
            В нашем руководстве мы указатели на коммиты никогда не будем называть ветками.
        </p>
        <p>
            <i>Веткой</i> будем называть цепочку коммитов, начинающуюся с отмеченного каким нибуть указателем коммита, и идущую вниз до первого ветвящегося коммита; а если такового нет, то до корневого коммита.
        </p>
        <p>
            Т.о. каждому указателю соответствует своя ветку.
            Имя указателя используется как имя соответствующей ему ветки.
        </p>
        <p>
            А теперь давайте разберемся как в git реализовано ветвление.
            Но начнем мы с создания указателей.
        </p>

        <h3>Создание указателей. Команда <i>git branch</i></h3>

        <p>При создании репозитория мы указывали имя начального указателя и соответственно начальной ветки
            (или это имя было выбрано по умолчанию: <i>main</i> или <i>master</i>).
            До сих пор у нас это существовал единственный указатель и единственная ветка <i>master</i>.
        </p>
        <p>
            Все прочие указатели, как правило, мы будем создавать сами.
            Для этого имеется команда <i>git branch &lt;name&gt; &lt;id-commit&gt;</i>
        </p>
        <p>
            Создадим указатель с именем <i>test</i> указывающий на второй коммит с идентификатором <i>03c1</i>.
        <pre><code style="color: blue">
$ git branch test 03c1
</code></pre>
        <p>Посмотрим список всех указателей</p>
        <pre><code style="color: blue">
$ git branch
* master
  test
</code></pre>
        <p>У нас теперь два указателя.
            Текущим по прежнему является указатель <i>master</i>.</p>
        <p>
            Новый указатель теперь можно использовать во всех командах вместо &lt;id-commit&gt;,
            в том числе в команде <i>git checkout</i>
        <pre><code style="color: blue">
$ git checkout test
Switched to branch 'test'

$ cat .git/HEAD
ref: refs/heads/test

$ git checkout master
Switched to branch 'master'

$ cat .git/HEAD
ref: refs/heads/master
</code></pre>
        Что произойдет, если
        текущим указателем сделать указатель <i>test</i> (тем самым вернув рабочий каталог к состоянию на момент второго коммита),
        внести изменения в какой-либо файл и зафиксировать получившееся состояние?
        <pre><code style="color: blue">
$ git checkout test
Switched to branch 'test'

$ cat file3
File3 v1

$ echo -n "File3 ver2" >> file3

$ cat file3
File3 v1File3 ver2

$ git add .

$ export GIT_AUTHOR_DATE="2000-01-01 00:04"

$ export GIT_COMMITTER_DATE="2000-01-01 00:04"

$ git commit -m "comment #4"
[test 6fff0ca] comment #4
 1 file changed, 1 insertion(+), 1 deletion(-)

$ git log --graph --all
* commit 6fff0ca362c2115be66b404992f61fe8fd9d3631 (HEAD -> test)
| Author: Ivan Ivanov &lt;ivan@localhost&gt;
| Date:   Sat Jan 1 00:04:00 2000 +0200
|
|     comment #4
|
| * commit 344b36ba2aeb489f97a4928816eeeefb30ddfac2 (master)
|/  Author: Ivan Ivanov &lt;ivan@localhost&gt;
|   Date:   Sat Jan 1 00:03:00 2000 +0200
|
|       comment #3
|
* commit 03c1a7f12800978dde0b8cd6383595e7007d0098
| Author: Ivan Ivanov &lt;ivan@localhost&gt;
| Date:   Sat Jan 1 00:02:00 2000 +0200
|
|     comment #2
|
* commit 69701b6e701d429882c083e98e1ecf195868b38c
  Author: Ivan Ivanov &lt;ivan@localhost&gt;
  Date:   Sat Jan 1 00:01:00 2000 +0200

      comment #1
</code></pre>
        Наша прежде линейная история разветвилась.
        Коммит <i>03c1</i> стал родителем уже двух коммитов.

        <h3>Пример использования ветвления и слияния</h3>

        <p>
            Создадим у себя на компьютере пустую папку и сделаем её <i>репозиторием Git</i>.
        <pre><code style="color: blue">
$ mkdir ~/project2
   
$ cd ~/project2
   
$ git init -b master
Initialized empty Git repository in .git/

$ git config user.name "Ivan Ivanov"

$ git config user.email "ivan@localhost"

$ nano dev.py
</code></pre>

        <pre><code style="color: blue">
x = 6
y = 2
print("x/y=",x/y)
</code></pre>

        <pre><code style="color: blue">
$ git add .

$ git commit -m "v1"
[master (root-commit) afb5303] v1
 1 file changed, 3 insertions(+)
 create mode 100644 dev.py

D:\Git\project2>python dev.py
x/y= 3
</code></pre>
        Пишем вторую версию программы
        <pre><code style="color: blue">
$ nano dev.py
</code></pre>

        <pre><code style="color: blue">
x = int(input("x="))
y = int(input("y="))
print("x/y=",x/y)
print("Спасибо за использование нашей программы!")
</code></pre>

        <pre><code style="color: blue">
$ git add .

$ git commit -m "v2"
[master (root-commit) afb5303] v1
 1 file changed, 3 insertions(+)
 create mode 100644 dev.py

D:\Git\project2>python dev.py
x=9
y=2
x/y= 4.5
</code></pre>
        Получаем задание «улучшить» интерфейс.
        Выполнять это задание будем в новой ветке «testing».
        <pre><code style="color: blue">
$ git branch testing

$ git checkout testing

$ nano dev.py
</code></pre>

        <pre><code style="color: blue">
x = int(input("x="))
y = int(input("y="))
print("x/y=",x/y)
print("Спасибо за использование нашей программы!")
# работаем ....
# ещё работаем ....
# и снова работаем ....
</code></pre>
        Но тут обнаружился "баг" в нашей программе.
        При делении на ноль наша программа некорректно завершает работу с выдачей непонятного для пользователя сообщения.
        <p>
            Получаем новое задание: отложить все дела и срочно устранить "баг".
        </p>
        <p>
        <pre><code style="color: blue">
$ git add .

$ git commit -m "незавершенная версия с улучшенным интерфейсом"

$ git checkout master

$ git branch hotfix

$ git checkout hotfix

$ nano dev.py
</code></pre>

        <pre><code style="color: blue">
x = int(input("x="))
y = int(input("y="))
if = 0:
    print("x/y=",x/y)
else:
    print("Извините, но делить на ноль нельзя")
print("Спасибо за использование нашей программы!")
</code></pre>

    </div>
</BODY>

</HTML>
