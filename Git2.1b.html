<HTML lang="ru">

<HEAD>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
    <TITLE>Git не для чайников (часть 2.1b)</TITLE>
    <meta name="KeyWords" content="git">
</HEAD>

<BODY>

    <div style="width:85%;  margin: auto;">

        <p><a href="http://htmlpreview.github.io/?https://github.com/konstant-in/doc1/blob/master/Git1.html">оригинал</a></p>

        <h3>Указатели</h3>

        <p>В системе git широко используется такая вещь, как указатель.
            <i>Указатель</i> это файл, в котором хранится идентификатор коммита, расположенный в каталоге <i>.git/refs/heads/</i> или его подкаталоге.
            <br><i>Имя указателя</i> - это имя соответствующего файла, и т.то на имена указателей распространяются те-же ограничения, что и на имена файлов.
            <br>В git-командах имя указателя можно использовать вместо идентификатора коммита.
            <br>Если укзатель находится в подкаталоге каталога <i>refs/heads/</i>, та обращаться к нему надо по полному имени <i>имя_подкаталога/имя_указателя</i>.
            <br>Например, если указатель имеет полное имя «iss/124», то указатель будет хранится в файле «124» в подкаталоге «iss».
        </p>
        <p>Указателей в репозитории может быть сколько угодно.</p>
        <p>Первый указатель создается автоматически, при создании первого коммита.
            Он получает имя указанное при инициализации репозитория.
            Раньше это было, как правило, имя <i>master</i>.
            Каждый созданный коммит будет записывать в указатель master свой идентификатор.</p>
        <p>Так будет происходить до тех пор пока текущим указателем будет оставаться указатель master.
            Текущий указатель хранится в файле .get/HEAD в формате: <i>ref: refs/heads/&lt;текущий_указатель&gt;</i>.</p>
        <p>Текущий указатель можно изменить командой <i>git checkout &lt;branchname&gt;</i>.
            Но прежде новый указатель надо создать командой <i>git branch &lt;branchname&gt; [&lt;commit-id&gt;]</i>.
            <br>
            Примечание: Если параметр &lt;commit-id&gt; опущен, то созданная указатель на текущий же коммит, но с другим именем.</p>
        <p>Поскольку все указатели хранятся в каталоге <i>.git/refs/heads/</i>, то один из способов посмотреть их список, выполнить команду ОС <i>find .git/refs/heads -type f</i>:</p>

        <pre><code style="color: blue">
$ find .git/refs/heads -type f
.git/refs/heads/master
</code></pre>

        <p>Для аналогичных целей служит штатная команда git <i>git branch</i> (без параметров) :</p>

        <pre><code style="color: blue">$ git branch
* master</code></pre>

        <p>Идентификатор коммита, хранящийся в указателе &lt;branchname&gt; можно посмотреть командой <i>git rev-parse &lt;branchname&gt;</i>, например:</p>

        <pre><code style="color: blue">$ git rev-parse master
e321b6cdf0bc52ca43effc8b975dbaa394baa9da</code></pre>

        <p>либо командой ОС:</p>

        <pre><code style="color: blue">$ cat .git/refs/heads/master
e321b6cdf0bc52ca43effc8b975dbaa394baa9da</code></pre>

        <h4>Символические указатели</h4>

        <p>Символическими указателями называются файлы хранящие имя указателя в формате: <i>ref: refs/heads/&lt;имя указателя&gt;</i>.
            Все символические указатели, хранятся непосредственно в каталоге .git/.</p>
        <p>Все??? символические указатели создаются автоматически???
            Они имеют имена В ВЕРХНЕМ РЕГИСТРЕ.
            Наиболее важными символическими ссылками являются: HEAD, ORIG_HEAD и MERGE_HEAD.</p>
        <p>Символический указатель, с именем HEAD мы уже рассмотрели.</p>

        <h3>Ветки</h3>

        <p>В книге по git постоянно используется термин ветка. Однако в разных местах в этот термин вкладывается разный смысл.
        То это некая последовательность коммитов (не очень понятго какая), то указатель на коммит.
        Мы <i>веткой</i> будем называть только последовательность коммитов (ниже четко определим какую именно), а <i>именем ветки</i> - имя указателя на первый коммит ветки.</p>

        <p><i>Ветка</i> - цепочка коммитов начинающаяся с некоторого указателя, идущая вниз и включающая в себя все коммит-объекты, созданные когда текущим был этот коммит.
        <br>Т.о. каждый указатель определяет свою ветку. Имя указателя одновременно является именем соответствующей ветки.</p>

        <p>Прежде чем создать новую ветку надо создать новый указатель и сделать его текущим.
            Коммиты созданные после этого будут относится к новой ветке.</p>

        <p>Склонируем проект project1 в папку project2</p>

        <pre><code style="color: blue">
$ git clone project1 project2
Cloning into 'project2'...
done.

$ cd project2

$ get status
bash: get: command not found

$ git branch
* master

$ git log
commit 344b36ba2aeb489f97a4928816eeeefb30ddfac2 (HEAD -> master, origin/master, origin/HEAD)
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:03:00 2000 +0200

    comment #3

commit 03c1a7f12800978dde0b8cd6383595e7007d0098
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:02:00 2000 +0200

    comment #2

commit 69701b6e701d429882c083e98e1ecf195868b38c
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:01:00 2000 +0200

    comment #1
</code></pre>
        Указатель master у нас уже есть. Он указывает на коммит 6970.
        <pre><code style="color: blue">
$ git rev-parse master
344b36ba2aeb489f97a4928816eeeefb30ddfac2
</code></pre>
        Создадим второй указатель с именем test указывающий на коммит (03c1).
        <pre><code style="color: blue">
$ git branch test 03c1

$ git rev-parse test
03c1a7f12800978dde0b8cd6383595e7007d0098
</code></pre>
        <p>
            Переключиться на указатель &lt;branchname&gt; можно командой <i>git checkout &lt;branchname&gt;</i>.
            Давайте переключаемся на созданный указатель test, посмотрим log, затем вернемся на master и снова посмотрим log.
        </p>
        <p>
        <pre><code style="color: blue">
$ git checkout test
Switched to branch 'test'

$ git log --oneline
03c1a7f (HEAD -> test) comment #2
69701b6 comment #1

$ git checkout master
Switched to branch 'master'
Your branch is up to date with 'origin/master'.

$ git log --oneline
344b36b (HEAD -> master, origin/master, origin/HEAD) comment #3
03c1a7f (test) comment #2
69701b6 comment #1
</code></pre>
        Ветка master состоит из коммитов 344b36b -> 03c1a7f -> 69701b6, а ветка test пока пустая.
        <p>
            Текущий указатель, в выводе команды <i>git branch</i>, отмечается звездочкой (*).
        <pre><code style="color: blue">
$ git branch
* master
  test
</code></pre>

        <h3>Ветвление в git</h3>

        <p>
            стр.58-...
        </p>

        <h3>Слияние в git</h3>

        <p>
            В классическом случае операция слияния - это
            <br><br>
            1. Формирование нового дерева, которое каким-то образом включает в себя изменения, произошедшие в сливаемых ветках со времени их общего предка.
            <br><br>
            2. Формирование нового коммита с этим деревом, в качестве предков которого указаны все сливаемые коммиты
        </p>
        <p>
            Автоматическая система слияния git в многих случаях может сама "слить" ветки, без участия пользователя. Например, если изменения в сливаемых ветках затрагивают разные файлы, или один и тот же файл, но изменяемые строчки не пересекаются. Новое дерево в таком случае формируется автоматически.
        </p>
        <p>
            В общем случае новое дерево автоматически сформироваться не может из за того, что одни изменения конфликтуют с другими. *********
        </p>

        <h3>Метки</h3>

        <p>
            Метки как ссылки и метки как объекты.
        </p>
        <p>
            стр.52-56
        </p>

        <h4>Легковесные метки</h4>

        <p>
            <i>Легковесная метка(lightweight teg)</i> - файл хранящий идентификатор объекта любого типа (блоб, дерево, коммит или объект-метку).
            <br>
            Легковесную метку можно использовать в git-командах вместо идентификатора объекта.
            <br>
            Имя указателя назначается только исходя из соображений удобства запоминания человеком.
            <br>
            На имя указателя распространяются только ограничения наложенные на имена файлов.
            <br>
            Метка создается командой <i>git tag -s &lt;tagname&gt; &lt;object&gt;</i>.
            <br>
            Метки хранятся в каталоге <i>.git/refs/tags/</i>.
            <br>
            Нет штатных средств с помощью которых можно изменить идентификатор объекта на который она указывает. Будучи однажды созданной, она продолжает указывать на один и тот же объект.
        </p>

        <h4>Тяжеловесные или аннотированные теги (annotated tag)</h4>

        <p>
            <i>Тяжеловесные или аннотированные теги (annotated tag)</i> - это объект еще одного типа.
            <br>
            В тело этого объекта записываются следующие данные:
        <pre><code style="color: blue">     * идентификатор объекта, на который тот указывает.
     * Тип объекта, на который тот указывает (blob, tree, commit или tag) (да, бывают теги  указывающие на теги!)
     * Имя легковесной метки, указывающей на этот анонсированный тег, и которая создается одновременно с ним.
     * Дата и время создания тега
     * Имя и e-mail создателя тега (в таком же формате как имя автора коммита)
     * Кусок произвольных данных на усмотрение создателя тега
</code></pre>
        Объект создается командой <i>git tag -a &lt;tagname&gt; &lt;object&gt;</i>.
        <p>Вместе с анонсированной меткой создается легковесная метка указывающая на этот объект.</p>
        <p>
            В кусок произвольных данных могут быть записано сообщение тега (по смыслу аналогичное сообщению коммита), а также в него можно внедрить GPG-подпись объекта. Такой тег будет называться подписанным(tag).
        </p>
        <p>
            Вот тут и проявляется магия git - создавая подписанный тег на определенный коммит, на самом деле подписывается и сам коммит, и вся его история, и все деревья, составляющие историю, и все блобы, "висящие на ветках этих деревьев". То есть все, на что можно "дотянуться" по ссылкам от коммита.
        </p>


    </div>
</BODY>

</HTML>
