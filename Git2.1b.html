<HTML lang="ru">

<HEAD>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
    <TITLE>Git не для чайников (часть 2.1b)</TITLE>
    <meta name="KeyWords" content="git">
</HEAD>

<BODY>

    <div style="width:85%;  margin: auto;">

        <p><a href="http://htmlpreview.github.io/?https://github.com/konstant-in/doc1/blob/master/Git1.html">оригинал</a></p>

        <h3>Указатели</h3>

        <p>В системе git широко используется такая вещь, как указатель.
            <i>Указатель</i> это файл, в котором хранится идентификатор коммита, расположенный в каталоге <i>.git/refs/heads/</i> или его подкаталоге.
            <br><i>Имя указателя</i> - это имя соответствующего файла, и т.то на имена указателей распространяются те-же ограничения, что и на имена файлов.
            <br>В git-командах имя указателя можно использовать вместо идентификатора коммита.
            <br>Если укзатель находится в подкаталоге каталога <i>refs/heads/</i>, та обращаться к нему надо по полному имени <i>имя_подкаталога/имя_указателя</i>.
            <br>Например, если указатель имеет полное имя «iss/124», то указатель будет хранится в файле «124» в подкаталоге «iss».
        </p>
        <p>Указателей в репозитории может быть сколько угодно.</p>
        <p>Первый указатель создается автоматически, при создании первого коммита.
            Он получает имя указанное при инициализации репозитория.
            Раньше это было, как правило, имя <i>master</i>.
            Каждый созданный коммит будет записывать в указатель master свой идентификатор.</p>
        <p>Так будет происходить до тех пор пока текущим указателем будет оставаться указатель master.
            Текущий указатель хранится в файле .get/HEAD в формате: <i>ref: refs/heads/&lt;текущий_указатель&gt;</i>.</p>
        <p>Текущий указатель можно изменить командой <i>git checkout &lt;branchname&gt;</i>.
            Но прежде новый указатель надо создать командой <i>git branch &lt;branchname&gt; [&lt;commit-id&gt;]</i>.
            <br>
            Примечание: Если параметр &lt;commit-id&gt; опущен, то созданная указатель на текущий же коммит, но с другим именем.</p>
        <p>Поскольку все указатели хранятся в каталоге <i>.git/refs/heads/</i>, то один из способов посмотреть их список, выполнить команду ОС <i>find .git/refs/heads -type f</i>:</p>

        <pre><code style="color: blue">
$ find .git/refs/heads -type f
.git/refs/heads/master
</code></pre>

        <p>Для аналогичных целей служит штатная команда git <i>git branch</i> (без параметров) :</p>

        <pre><code style="color: blue">$ git branch
* master</code></pre>

        <p>Идентификатор коммита, хранящийся в указателе &lt;branchname&gt; можно посмотреть командой <i>git rev-parse &lt;branchname&gt;</i>, например:</p>

        <pre><code style="color: blue">$ git rev-parse master
e321b6cdf0bc52ca43effc8b975dbaa394baa9da</code></pre>

        <p>либо командой ОС:</p>

        <pre><code style="color: blue">$ cat .git/refs/heads/master
e321b6cdf0bc52ca43effc8b975dbaa394baa9da</code></pre>

        <h4>Символические указатели</h4>

        <p>Символическими указателями называются файлы хранящие имя указателя в формате: <i>ref: refs/heads/&lt;имя указателя&gt;</i>.
            Все символические указатели, хранятся непосредственно в каталоге .git/.</p>
        <p>Все??? символические указатели создаются автоматически???
            Они имеют имена В ВЕРХНЕМ РЕГИСТРЕ.
            Наиболее важными символическими ссылками являются: HEAD, ORIG_HEAD и MERGE_HEAD.</p>
        <p>Символический указатель, с именем HEAD мы уже рассмотрели.</p>

        <h3>Ветки</h3>

        <p>В книге по git постоянно используется термин ветка. Однако в разных местах в этот термин вкладывается разный смысл.
        То это некая последовательность коммитов (не очень понятго какая), то указатель на коммит.
        Мы <i>веткой</i> будем называть только последовательность коммитов (ниже четко определим какую именно), а <i>именем ветки</i> - имя указателя на первый коммит ветки.</p>

        <p><i>Ветка</i> - цепочка коммитов начинающаяся с некоторого указателя, идущая вниз и включающая в себя все коммит-объекты, созданные когда текущим был этот коммит.
        <br>Т.о. каждый указатель определяет свою ветку. Имя указателя одновременно является именем соответствующей ветки.</p>

        <p>Прежде чем создать новую ветку надо создать новый указатель и сделать его текущим.
            Коммиты созданные после этого будут относится к новой ветке.</p>

        <p>Склонируем проект project1 в папку project2</p>

        <pre><code style="color: blue">
$ git clone project1 project2
Cloning into 'project2'...
done.

$ cd project2

$ get status
bash: get: command not found

$ git branch
* master

$ git log
commit 344b36ba2aeb489f97a4928816eeeefb30ddfac2 (HEAD -> master, origin/master, origin/HEAD)
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:03:00 2000 +0200

    comment #3

commit 03c1a7f12800978dde0b8cd6383595e7007d0098
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:02:00 2000 +0200

    comment #2

commit 69701b6e701d429882c083e98e1ecf195868b38c
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:01:00 2000 +0200

    comment #1
</code></pre>
        Указатель master у нас уже есть. Он указывает на коммит 6970.
        <pre><code style="color: blue">
$ git rev-parse master
344b36ba2aeb489f97a4928816eeeefb30ddfac2
</code></pre>
        Создадим второй указатель с именем test указывающий на коммит (03c1).
        <pre><code style="color: blue">
$ git branch test 03c1

$ git rev-parse test
03c1a7f12800978dde0b8cd6383595e7007d0098
</code></pre>
        <p>
            Переключиться на указатель &lt;branchname&gt; можно командой <i>git checkout &lt;branchname&gt;</i>.
            Давайте переключаемся на созданный указатель test, посмотрим log, затем вернемся на master и снова посмотрим log.
        </p>
        <p>
        <pre><code style="color: blue">
$ git checkout test
Switched to branch 'test'

$ git log --oneline
03c1a7f (HEAD -> test) comment #2
69701b6 comment #1

$ git checkout master
Switched to branch 'master'
Your branch is up to date with 'origin/master'.

$ git log --oneline
344b36b (HEAD -> master, origin/master, origin/HEAD) comment #3
03c1a7f (test) comment #2
69701b6 comment #1
</code></pre>
        Ветка master состоит из коммитов 344b36b -> 03c1a7f -> 69701b6, а ветка test пока пустая.
        <p>
            Текущий указатель, в выводе команды <i>git branch</i>, отмечается звездочкой (*).
        <pre><code style="color: blue">
$ git branch
* master
  test
</code></pre>

        <h3>Ветвление в git</h3>

        <p>
            стр.58-...
        </p>

        <h3>Слияние в git</h3>

        <p>
            В классическом случае операция слияния - это
            <br><br>
            1. Формирование нового дерева, которое каким-то образом включает в себя изменения, произошедшие в сливаемых ветках со времени их общего предка.
            <br><br>
            2. Формирование нового коммита с этим деревом, в качестве предков которого указаны все сливаемые коммиты
        </p>
        <p>
            Автоматическая система слияния git в многих случаях может сама "слить" ветки, без участия пользователя. Например, если изменения в сливаемых ветках затрагивают разные файлы, или один и тот же файл, но изменяемые строчки не пересекаются. Новое дерево в таком случае формируется автоматически.
        </p>
        <p>
            В общем случае новое дерево автоматически сформироваться не может из за того, что одни изменения конфликтуют с другими. *********
        </p>

        <h3>Метки</h3>

        <p>Метки как ссылки и метки как объекты.</p>

        <p>стр.52-56</p>

        <h4>Легковесные метки</h4>

        <p><i>Легковесная метка(lightweight teg)</i> - файл хранящий идентификатор объекта любого типа (блоб, дерево, коммит или объект-метку).
        <br>Легковесную метку можно использовать в git-командах вместо идентификатора объекта.
        <br>Имя указателя назначается только исходя из соображений удобства запоминания человеком.
        <br>На имя указателя распространяются только ограничения наложенные на имена файлов.
        <br>Метка создается командой <i>git tag -s &lt;tagname&gt; &lt;object&gt;</i>.
        <br>Метки хранятся в каталоге <i>.git/refs/tags/</i>.
        <br>Нет штатных средств с помощью которых можно изменить идентификатор объекта на который она указывает. Будучи однажды созданной, она продолжает указывать на один и тот же объект.</p>

        <h4>Тяжеловесные или аннотированные теги (annotated tag). Объект <i>tag</i></h4>

        <p><i>Тяжеловесные или аннотированные теги (annotated tag)</i> - это объект типа-<i>tag</i>, содержащий в теле следующие данные:</p>

        <ul>
         <li>После слова <i>object</i> - идентификатор объекта, на который тот указывает.</li>
         <li>После слова <i>type</i> - тип объекта, на который тот указывает (blob, tree, commit или tag) (да, бывают теги  указывающие на теги!)</li>
         <li>После слова <i>tag</i> - имя легковесной метки, указывающей на этот анонсированный тег, и которая создается одновременно с ним.</li>
         <li>После слова <i>tegger</i> - имя и e-mail создателя тега, а также дата и время создания тега (в таком же формате как в коммите)</li>
         <li>Сообщение тега, представляющее собой произвольных текст на усмотрение создателя тега.
        </ul>

        <p>Как и все другие объекты он хранитмя в <i>.git/objects</i>.</p>

        <p>&lt;tag&gt;-объект создается командой <i>git tag -a &lt;tagname&gt; &lt;id-object&gt; -m &lt;msg&gt;</i>.</p>

        <p>Вместе с анонсированной меткой создается легковесная метка с именем &lt;tagname&gt; указывающая на созданный &lt;tag&gt;-объект.</p>


<pre><code style="color: blue">$ git tag -a mytag -a  e944699cf877b9c2c56806dc1c85c87efbc0ecb4

$ ls -l .git/refs/tags/
total 1
-rw-r--r-- 1 konst 197609 41 Sep 22 08:59 mytag

$ cat .git/refs/tags/mytag
76d5e92d5816a68a82dd9673f2fee0fe221fb106/code>

$ git cat-file -t 76d5
tag

konst@HP-G6 MINGW64 ~/Projects/doc_git (main)
$ git cat-file -p 76d5
object e944699cf877b9c2c56806dc1c85c87efbc0ecb4
type commit
tag mytag
tagger Konstantin Kulikin <konstantin2000@gmail.com> 1695362328 +0300

kkkkkk

$ git cat-file -p e944
tree 31d9db088d5310da49f77990c7b5f8d4216f885a
parent 79bae70f2c513ad00f480a939c54eb7879fe8a93
author Konstantin Kulikin <konstantin2000@gmail.com> 1695354047 +0300
committer Konstantin Kulikin <konstantin2000@gmail.com> 1695354047 +0300

rename files

$ git cat-file -t e944
commit</code></pre>

        <p>В сообщениии тега можно внедрить GPG-подпись объекта. Такой тег будет называться подписанным(tag).</p>
        <p>Вот тут и проявляется магия git - создавая подписанный тег на определенный коммит, на самом деле подписывается и сам коммит, и вся его история, и все деревья, составляющие историю, и все блобы, "висящие на ветках этих деревьев". То есть все, на что можно "дотянуться" по ссылкам от коммита.</p>


    </div>
</BODY>

</HTML>
