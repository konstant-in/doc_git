<HTML lang="ru">

<HEAD>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
    <TITLE>Git не для чайников (часть 2)</TITLE>
    <meta name="KeyWords" content="git">
</HEAD>

<BODY>

    <div style="width:85%;  margin: auto;">

        <p><a href="http://htmlpreview.github.io/?https://github.com/konstant-in/doc1/blob/master/Git.html">оригинал</a></p>

        <h3>База объектов репозитария</h3>

        <p>
            Одной из важнейших составных частей репозитария является <i>база объектов</i> - подкаталог <i>objects</i> каталога <i>.git</i>.
            <br>
            В базе объектов хранится история версий всех отслеживаемых файлов репозитория.
            Эта информация хранится в виде файлов специального формата т.н. <i>объектов (objects) Git</i>.
            <br>
            Объекты Git состоят из <i>тела</i> и <i>заголовка</i> сжатых с помощью библиотеки zlib.
            Тело объекта содержит непосредственно информацию, которую требуется сохранить, а заголовок тип этой информации (<i>тип объекта</i>) и размер тела в байтах.
            <br>
            У каждого объекта имеется уникальный <i>идентификатор (id)</i>, который вычисляется как SHA1 хеш заголовка и тела объекта.
            SHA1 хеш является 40 разрядным шестнадцатеричным числом.
            Следовательно идентификатор объекта состоит из 40 символов (цифр от <i>0</i> до <i>9</i> и букв от <i>a</i> до <i>e</i>).
            <br>
            Вычисляется хеш-функция SHA1 очень быстро.
        </p>
        <p>
            Хеш-функция - это своеобразный "отпечаток пальца" объекта. Он обладает следующими свойствами:
        </p>
        <ol>
            <li>
                Если содержимое двух объектов совпадает - то их хеши тоже совпадают.
            </li>
            <li>
                Если содержимое двух объектов различны - то их хеши тоже различны (хеш-функция SHA1 считается
                достаточно сложной для подбора или случайного возникновения коллизии).
            </li>
        </ol>

        <p>
            Использование SHA1 хеш для именования объектов позволяет быстро и однозначно идентифицировать объект, а также проверить его целостность - если объект повредился, его хеш не совпадет с именем.
            Данная функциональность встроена в Git на низком уровне и является неотъемлемой частью его философии.
            Вы не потеряете информацию во время её передачи и не получите повреждённый файл без того, чтобы Git не обнаружил это.
        </p>
        <p>
            Перед сохранением объекта в базе объектов Git отделяет первые два символа идентификатора объекта и создает поддиректорию с именем из этих двух символов в каталоге .git/objects.
            В этой поддиректории и сохраняется объект, под именем получающимся отбрасыванием первых двух символов от идентификатора объекта.
            <br>
            Например объект с идентификатором aa49df5d247524e94f09e2fe86ed6c0b96814eb0 будет хранится в каталоге .git/objects/aa, как файл с именем 49df5d247524e94f09e2fe86ed6c0b96814eb0
        </p>
        <p>
            В больших проектах объектов в базе очень много. Если бы все объекты хранились в одном каталоге, то их число могло превысить максимальное количество файлов, которое может хранится в одном каталоге или это могло бы вызвать снижения производительности (общее число объектов снижает и packs см.далее).
        </p>
        <p>
            Посмотрим все его объекты, находящиеся в каталоге <i>.git/objects</i> из нашего первого примера.
        <pre><code style="color: blue">
$ find .git/objects -type f
.git/objects/03/c1a7f12800978dde0b8cd6383595e7007d0098
.git/objects/1d/5260cb0591933230fdaaa8035a94b8e393ea20
.git/objects/27/63fac853abca428edd5c2a1b48ef5d212ff99a
.git/objects/34/4b36ba2aeb489f97a4928816eeeefb30ddfac2
.git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4
.git/objects/69/701b6e701d429882c083e98e1ecf195868b38c
.git/objects/6c/59b709d4abf607ab16a03b22db93412fe437a4
.git/objects/96/6e9a46c8df9aa3b2108864be07abe7b5d1d0f9
.git/objects/ad/2a32f77c6c6eac140b94619e332c89d1319b6b
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f
.git/objects/b8/92ad555729a5275bb9ba81158e2a708da84b11
</code></pre>
        Если посмотреть, содержимое объектов непосредственно каким нибудь редактором, то вместо содержимого поля и тела
        объекта, мы увидим мешанину нечитаемых символов. Это происходит потому, что заголовок и тело объекта перед записью
        сжимаются с помощью библиотеки zlib. Сжатие позволяет существенно уменьшить размер репозитория.

        <h3>Типы объектов</h3>

        <p>
            Объекты git бывают четырех типов: <i>blob</i>, <i>tree</i>, <i>commit</i> и <i>tag</i>.
        </p>
        <p>
            Тип любого объекта можно посмотреть командой <i>git cat-file</i> с ключем <i>-t</i>
        </p>
        <p>
            В нашем репозитарии имеется 11 следующих объектов:
        <pre><code style="color: blue">
03c1a7f12800978dde0b8cd6383595e7007d0098
1d5260cb0591933230fdaaa8035a94b8e393ea20
2763fac853abca428edd5c2a1b48ef5d212ff99a
344b36ba2aeb489f97a4928816eeeefb30ddfac2
475190118d49d9905c1a82c6fd11dab9ab602cc4
69701b6e701d429882c083e98e1ecf195868b38c
6c59b709d4abf607ab16a03b22db93412fe437a4
966e9a46c8df9aa3b2108864be07abe7b5d1d0f9
ad2a32f77c6c6eac140b94619e332c89d1319b6b
b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f
b892ad555729a5275bb9ba81158e2a708da84b11
</code></pre>
        Проверим типы всех этих объектов.
        <pre><code style="color: blue">
$ git cat-file -t 03c1
commit

$ git cat-file -t 1d52
blob

$ git cat-file -t 2763
tree

$ git cat-file -t 344b
commit

$ git cat-file -t 4751
blob

$ git cat-file -t 6970
commit

$ git cat-file -t 6c59
tree

$ git cat-file -t 966e
tree

$ git cat-file -t ad2a
blob

$ git cat-file -t b2fb
blob

$ git cat-file -t b892
tree
</code></pre>
        Итого из 11 объектов: 4 - blob, 4 - tree, 3 - commit.

        <h3>Объект типа blob</h3>

        <p>
            Объекты типа <i>blob</i> (Binary Large Object) - это основа репозитория.
            <br>
            Тела таких объектов хранят только содержимое файлов.
            Кроме содержимого файла в теле блоба, более не содержится ничего, в том числе там нет информации и о имени файла.
            <br>
            Имя файла и другая информация о файле сохраняются в объектах типа tree.
            <br>
            Это очень похоже на способ хранения информации в файловых системах Linux.
        </p>

        <p>
            Тело blob-объекта можно посмотреть командой <i>git cat-file</i>, с ключем <i>blob</i> или с ключем <i>-p</i> (с ним тип объекта определяется автоматически).
        </p>
        <p>
            Посмотрим тела всех наши блобов (содержимое всех версий файлов).
        <pre><code style="color: blue">
$ git cat-file -p 1d52
File1 v1
Second line (v2)

$ git cat-file -p 4751
File1 v1

$ git cat-file -p ad2a
File3 v1

$ git cat-file -p b2fb
File2 v1
</code></pre>

        <h3>Объекты типа tree</h3>

        <p>
            Как уже было сказано имена файлов и каталогов хранятся в объектах типа <i>дерево (tree)</i>. Имена файлов и каталогов сохраняются вместе с путями. Помимо имён файлов и каталогов в дереве хранятся типы, права доступа и идентификаторы блобов файлов и идентификаторы других деревьев включенных в данное дерево.
        </p>
        <p>
            Дерево git-а аналогично каталогу файловой системы, а blob аналогичен inode.
            Деревья образуют иерархию, аналогичную иерархии каталогов и файлов.
        </p>
        <p>
            Тело дерева хранит список записей, в котором каждая запись состоит из четырех полей:
        <ul>
            <li>
                Первое поле: шесть восьмеричных цифр.
                <ul>
                    <li>
                        Первая цифра: 1 для файлов, 0 для директорий.
                    <li>
                        Вторая цифра: 0 для обычных файлов, 2 для символических ссылок????, 4 - для директорий
                    <li>
                        Третья цифра: Всегда 0 (не используется).
                    <li>
                        Четвертая, пятая и шестая цифры: права владельца файла, права группы владельца и права остальных пользователей, записанные как комбинация цифр 4, 2 и 1 (4 - право на чтение, 2 - право на запись, 1 - право на выполнение).
                </ul>
            <li>
                Второе поле: Тип объекта, на который ссылается элемент списка. Может быть <i>blob</i> или <i>tree</i>.
            </li>
            <li>
                Третье поле: Ссылка - SHA1 хеш объекта, который однозначно определяет объект в репозитории git.
            </li>
            <li>
                Четвертое поле: Имя файла (если ссылка на <i>blob</i>) или имя директории (если ссылка на <i>tree</i>).
            </li>
        </ul>
        <p>
            Замечание: Права владельца файла, права группы владельца и права остальных пользователей используются а файловых системах UNIX и Linux. Используются ли они в операционной системе Windows?
            <br>
            Разрешены только такие права 644 или 755 для обычных файлов. И 664?
            <br>
            Итого все возможные комбинации:
            <br>
            040000: Каталог
            <br>
            100644: Обычный не исполняемый файл
            <br>
            100755: Обычный исполняемый файл
            <br>
            ??????? 100664: Обычный не исполняемый файл с правом записи для группы владельца
            <br>
            120000: Символическая ссылка
            <br>
            160000: Gitlink
        </p>
        <p>
            Объект-дерево после создания получает свой идентификатор на основе SHA1 хеша, и может быть после этого включен в другие деревья.
            Деревья строятся на основании информации содержащийся в индексе, а не фактического содержания рабочего каталога. Это важно для понимания работы git.
        </p>
        <p>
            Объекты-деревья служат для объединения blob-объектов и деревьев в <i>снимки(snapshot)</i> - иерархии, аналогичные каталогам файловой системе.
        </p>
        <p>
            Посмотреть содержимое дерева можно, командой <i>git ls-tree</i>, командой <i>cat-file</i> с ключем <i>-p</i>.
        </p>
        <p>
            Посмотрим содержимое всех деревьев нашего репозитория
        <pre><code style="color: blue">
$ git cat-file -p 2763
040000 tree 966e9a46c8df9aa3b2108864be07abe7b5d1d0f9    d
100644 blob 475190118d49d9905c1a82c6fd11dab9ab602cc4    file1
100644 blob ad2a32f77c6c6eac140b94619e332c89d1319b6b    file3

$ git cat-file -p 6c59
040000 tree 966e9a46c8df9aa3b2108864be07abe7b5d1d0f9    d
100644 blob 475190118d49d9905c1a82c6fd11dab9ab602cc4    file1

$ git cat-file -p 966e
100644 blob b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f    file2

$ git cat-file -p b892
040000 tree 966e9a46c8df9aa3b2108864be07abe7b5d1d0f9    d
100644 blob 1d5260cb0591933230fdaaa8035a94b8e393ea20    file1
100644 blob ad2a32f77c6c6eac140b94619e332c89d1319b6b    file3
</code></pre>
        <p>
            <i>Снимок (snapshot) системы</i> - это дерево вместе со всеми объектами на которые оно по цепочке ссылается.
            Любое дерево, определяет снимок всего рабочего каталога, либо какого-то его подкаталога.
        </p>
        <p>
            По четырем объектам-деревьям построим три снимка репозитория.
        </p>
        <p>
            Первый
        <pre><code style="color: blue">
6c59 ---+--&gt; 4751 (файл «file1»)
        |
        +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
        И второй
        <pre><code style="color: blue">
2763 ---+--&gt; 4751 (файл «file1»)
        |
        +--&gt; ad2a (файл «file3»)
        |
        +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
        И третий
        <pre><code style="color: blue">
b892 ---+--&gt; 1d52 (файл «file1» v2)
        |
        +--&gt; ad2a (файл «file3»)
        |
        +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
        <p>
            Рассмотрим, чем полезно, то что идентификаторы объектов (в том числе деревьев) являются хешем их содержимого.
        </p>
        <p>
            Пусть у двух объектов-деревьев одинаковые идентификаторы.
            Что это означает? Что внутренности этих деревьев совпадают!
            А так как внутренности деревьев - это ссылки на объекты, то это означает что два дерева ссылаются на одни и те же объекты. Которые в свою очередь тоже могут быть деревьями или блобами.
            Таким образом идентификатор дерева на самом деле идентифицирует не только "файлы в одной директории", но и все файлы во всех поддиректориях этой директории - одно имя для всей иерархии!
        </p>
        <p>
            Это свойство позволяет git-у очень быстро производить сравнение
            деревьев со сколь угодно сложной иерархией, уровнями вложенности и т.д.
            без чтения собственно содержимого - blob-ов или tree.

        </p>
        <p>

            При помощи Git-команды <i>git diff-tree</i> можно посмотреть разницу между двумя деревьями.
        <pre><code style="color: blue">
$ git diff-tree 6c59 2763
:000000 100644 0000000000000000000000000000000000000000 ad2a32f77c6c6eac140b94619e332c89d1319b6b A  file3

$ git diff-tree 2763 b892
:100644 100644 475190118d49d9905c1a82c6fd11dab9ab602cc4 1d5260cb0591933230fdaaa8035a94b8e393ea20 M  file1
</code></pre>
        <p>
            A - файл добавлен (added)
            <br>
            D - файл удален (deleted)
            <br>
            M - изменен (modified)
        </p>

        <h3>Объекты типа commit</h3>

        <p>
            Git не был бы системой контроля версий, если бы не позволял хранить историю изменений деревьев.
            Для хранения истории в git используются специальные объекты-коммиты (commits), ссылающиеся друг на друга.
            Если коммит B ссылается другой коммит A (A ← B), то говорят, что A для B является родителем (parent) или предком;
            а B для A - ребенком (child) или потомком.
            Коммит может иметь несколько родителей, либо не иметь ни одного.
            Стандартная ситуация - у каждого коммита один родитель.
        </p>
        <p>
            Тело объекта-коммит содержит следующую информацию:
        <pre><code style="color: blue">
   * ссылку на объект-дерево, который хранит иерархию рабочего каталога (первая строчка);
   * ссылка на родителя, если таковой есть; если родителей несколько, то каждый родитель на отдельной строчке;
   * author – это человек, внесший изменения в файлы проекта;
   * время создания изменений;
   * committer - это человек, внесший изменения в историю проекта, т.е. выполнивший команду git commit;
   * время фиксации изменений;
   * сообщение - пояснительный текст к коммиту.
</code></pre>
        <p>
            У коммита может быть ноль или более родителей. Обычно родителей нет только у одного первого коммита.
            Если в истории коммитов есть коммиты у которых более одного предка, то говорят о <i>слиянии</i> коммитов.
            Если в истории коммитов есть коммиты которые являются предками для нескольких коммитов, то говорят о <i>ветвлении</i> коммитов.
            Репозитории без ветвлений и слияний называется <i>линейными</i>.
        </p>
        Автором и коммитером обычно бывает один человек. В этом случае поля author и committer совпадают.
        <p>
            Поля author и committer и их почтовые адреса заполняются на основании переменных окружения:
        <pre><code style="color: blue">
GIT_AUTHOR_NAME
GIT_AUTHOR_EMAIL
GIT_COMMITTER_NAME
GIT_COMMITTER_EMAIL
</code></pre>
        Если эти переменные окружения не установлены, то значения берутся из локального или глобального файла конфигурации.
        <p>
            Поля время создания и фиксации изменений заполняются на основании переменных окружения:
        <pre><code style="color: blue">
GIT_AUTHOR_DATE
GIT_COMMITTER_DATE
</code></pre>
        Как правило эти переменные окружения не установлены и временем создании и фиксации изменений считается текущее
        время.
        <p>
            При помощи параметров --author=<i>имя &lt;email&gt;</i> и --date=<i>время</i> команды git commit можно переопределить поля author и время создания изменений.
        </p>
        <p>
            Наличие в объекте commit имени автора и коммитера, а также времени создания и фиксации изменений приводит к тому, что при прочих равных обстоятельствах команда <i>git commit</i> создает, в разное время или на разных компьютерах, коммиты с разными идентификаторами. В учебных примерах это не удобно, поэтому мы в примерах время будем задавать в переменных окружения командной строки:
        <pre><code style="color: blue">
$ export GIT_AUTHOR_DATE="2000-01-01 00:00:00"
$ export GIT_COMMITTER_DATE="2000-01-01 00:00:00"
</code></pre>
        А автора и коммитера в локальном файле конфигурации:
        <pre><code style="color: blue">
git config user.name "Ivan Ivanov"
git config user.email "ivan@localhost"
</code></pre>

        <p>
            Содержимое коммита можно посмотреть командой <i>cat-file</i> с ключем <i>commit</i> или с ключем <i>-p</i>.
        </p>
        <p>
            Посмотрим содержимое всех коммитов нашего репозитория
        <pre><code style="color: blue">
$ git cat-file -p 03c1
tree 2763fac853abca428edd5c2a1b48ef5d212ff99a
parent 69701b6e701d429882c083e98e1ecf195868b38c
author Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200
committer Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200

comment #2

$ git cat-file -p 344b
tree b892ad555729a5275bb9ba81158e2a708da84b11
parent 03c1a7f12800978dde0b8cd6383595e7007d0098
author Ivan Ivanov &lt;ivan@localhost&gt; 946677780 +0200
committer Ivan Ivanov &lt;ivan@localhost&gt; 946677780 +0200

comment #3

$ git cat-file -p 6970
tree 6c59b709d4abf607ab16a03b22db93412fe437a4
author Ivan Ivanov &lt;ivan@localhost&gt; 946677660 +0200
committer Ivan Ivanov &lt;ivan@localhost&gt; 946677660 +0200

comment #1
</code></pre>
        <p>
            Команда выводит всю информацию хранящуюся в коммите
        </p>
        <p>
            Стандартный log выводит немного меньше информации
        <pre><code style="color: blue">
$ git log
commit 344b36ba2aeb489f97a4928816eeeefb30ddfac2 (HEAD -> master)
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:03:00 2000 +0200

    comment #3

commit 03c1a7f12800978dde0b8cd6383595e7007d0098
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:02:00 2000 +0200

    comment #2

commit 69701b6e701d429882c083e98e1ecf195868b38c
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:01:00 2000 +0200

    comment #1
</code></pre>
        Настроем сокращенные log и дадим ему алиас hist:
        <pre><code style="color: blue">
$ git config --global alias.hist "log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short"
</code></pre>
        Посмотрим сокращенный log:
        <pre><code style="color: blue">
$ git hist
* 344b36b 2000-01-01 | comment #3 (HEAD -> master) [Ivan Ivanov]
* 03c1a7f 2000-01-01 | comment #2 [Ivan Ivanov]
* 69701b6 2000-01-01 | comment #1 [Ivan Ivanov]
</code></pre>
        Т.о. мы имеем хронологическую последовательность коммитов ссылающихся на снимки.
        <pre><code style="color: blue">
6970 (commit #1) --&gt; 6c59 ---+--&gt; 4751 (файл «file1»)
|                            |
|                            +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
↓
03c1 (commit #2) --&gt; 2763 ---+--&gt; 4751 (файл «file1»)
|                            |
|                            +--&gt; ad2a (файл «file3»)
|                            |
|                            +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
↓
344b (commit #3) --&gt; b892 ---+--&gt; 1d52 (файл «file1» v2)
                             |
                             +--&gt; ad2a (файл «file3»)
                             |
                             +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
        Последний коммит, в цепочке коммитов, называется <i>текущим</i>.


        <h4>Индекс (index)</h4>

        <p>
            Как мы уже сказали, что команда <i>git add</i> выполняет два действия: делает файл отслеживаемым и создает соответствующий этому файлу blob-объект.
            Но, что значит "сделать файл отслеживаемым"? Где хранится информация об отслеживаемых файлах?
        </p>
        <p>
            Хранится она <i>индексе</i> - файле .git/index. Индекс содержит список всех файлов, версии которые мы хотим сохранять.
        </p>

        <p>
            Команда <i>git add &lt;файл&gt;</i> сохраняет в индексе информацию об атрибутах файла (типе файла и правах доступа), идентификаторе блоб-объекта соответствующего этому файлу, имя файла вместе с относительным путем к этому файлу. (Также время создания/модификации, но это не попадает в коммит. Только для более быстрого сравнивания?????????)
        </p>
        <p>
            Содержимое индекса можно посмотреть командой git ls-files. Посмотрим, что у нас там сейчас находится:
        <pre><code style="color: blue">    $ git ls-files --stage
    100644 b45ef6fec89518d314f546fd6c3025367b721684 0       tutorial.txt

</code></pre>
        Из вывода команды видно, что в индексе присутствует единственный файл с именем tutorial.txt с атрибутами 100644 и
        что содержимое этого файла можно извлечь из blob-объекта с идентификатором b45ef6fec89518d314f546fd6c3025367b721684.

        <p>
            Если в рабочую папку git положить любое количество файлов с абсолютно одинаковым содержимым, и для каждого выполнить команду <i>git add</i> то, из-за того что blob-объекты не содержат никакой информации об именах файлов, всем им будет соответствовать один blob-объект, который <b>не будет</b> перезаписываться.
            <br>
            Это уменьшает размеры репозиториев хранящих большое количество одинаковых файлов.
        </p>

        <pre><code style="color: blue">
   $ cp tutorial.txt tutorial2.txt

   $ git add tutorial2.txt
   warning: LF will be replaced by CRLF in tutorial2.txt.
   The file will have its original line endings in your working directory

   $ cp tutorial.txt tutorial3.txt

   $ git add tutorial3.txt
   warning: LF will be replaced by CRLF in tutorial3.txt.
   The file will have its original line endings in your working directory

   $ find .git/objects -type f
   .git/objects/b4/5ef6fec89518d314f546fd6c3025367b721684

   $ git ls-files --stage
   100644 b45ef6fec89518d314f546fd6c3025367b721684 0       tutorial.txt
   100644 b45ef6fec89518d314f546fd6c3025367b721684 0       tutorial2.txt
   100644 b45ef6fec89518d314f546fd6c3025367b721684 0       tutorial3.txt
</code></pre>
        <p>
            Из вывода последней команды видно, что git в данный момент отслеживает состояние трех файлов: tutorial1.txt, tutorial2.txt и tutorial3.txt, и что содержимое всех этих файлов одинаковое, т.к. всем трем файлам соответствует один и тотже blob-объект.
        </p>

        <h4>Утилита gzip</h4>

        <p>
            Если нам, для каких либо целей, захочется посмотреть содержимое объектов не используя утилиты git, то это можно сделать при помощи утилиты gzip. Она реализует тот же алгоритм сжатия, что и библиотека zlib.
            Но поскольку утилита gzip не только сжимает файл, но и добавляет в его начало заголовок "\x1f\x8b\x08\x00\x00\x00\x00\x00", которого нет в объектах git, то , перед распаковкой объекта утилитой gzip, заголовок надо добавить искуственно.
        </p>
        <p>
            Чтобы распаковать blob-объект b45ef6fec89518d314f546fd6c3025367b721684, выполним:

        <pre><code style="color: blue">
   $ echo -en "\x1f\x8b\x08\x00\x00\x00\x00\x00" |cat - .git/objects/b4/5ef6fec89518d314f546fd6c3025367b721684 |gzip -dc
   blob 13Hello, World!
   gzip: stdin: unexpected end of file
</code></pre>
        Мы видим заголовок и тело объекта вместе.


        <h4>Указатели. Указатель <i>master</i></h4>

        <p>В системе git широко используется такая вещь, как указатель.
            <i>Указатель</i> это файл в каталоге <i>.git/refs/heads/</i> в котором хранится идентификатор коммита.
            В git-командах указатель можно использовать вместо идентификатора коммита.
            Имя указателя назначается только исходя из соображений удобства запоминания человеком.
            На имя указателя распространяются только ограничения наложенные на имена файлов.
            <br>
            В имени указателя допустимы прямые слеши (/).
            Если имя указателя будет содержать слеш, например iss/124, то указатель будет хранится в файле «124» в подкаталоге «iss».
        </p>
        <p>
            Указателей веток в репозитории может быть сколько угодно.
        </p>
        <p>
            Первый указатель создается автоматически, при создании первого коммита.
            Он получает имя <i>master</i> и в него записывается идентификатор этого коммита.
            Каждый вновь созданный коммит будет записывать в указатель master свой идентификатор,
            а в качестве родителя записывать предыдущее значение указателя. Например: ...
        </p>
        <p>
            Так будет происходить до тех пор пока текущим указателем будет оставаться указатель master.
            Текущий указатель хранится в файле .get/HEAD в формате: <i>ref: refs/heads/&lt;текущий_указатель&gt;</i>.
        </p>
        <p>
            Текущий указатель можно изменить командой <i>git checkout &lt;branchname&gt;</i>.
            Но прежде новый указатель надо создать командой <i>git branch &lt;branchname&gt; [&lt;commit-id&gt;]</i>.
            <br>
            Примечание: Если параметр &lt;commit-id&gt; опущен, то созданная указатель на текущий же коммит, но с другим именем.
        </p>
        <p>
            Поскольку все указатели хранятся в каталоге <i>.git/refs/heads/</i>, то один из способов посмотреть их список, выполнить команду ОС <i>find .git/refs/heads -type f</i>:
        <pre><code style="color: blue">
$ find .git/refs/heads -type f
.git/refs/heads/master
</code></pre>
        Для аналогичных целей служит команда git <i>git branch</i> (без параметров) :
        <pre><code style="color: blue">
$ git branch
* master
</code></pre>
        <p>
            Идентификатор коммита, хранящийся в указателе &lt;branchname&gt; можно посмотреть командой <i>git rev-parse &lt;branchname&gt;</i>, например:
        <pre><code style="color: blue">
$ git rev-parse master
e321b6cdf0bc52ca43effc8b975dbaa394baa9da
</code></pre>
        либо командой ОС:
        <pre><code style="color: blue">
$ cat .git/refs/heads/master
e321b6cdf0bc52ca43effc8b975dbaa394baa9da
</code></pre>

        <h4>Символические указатели</h4>

        <p>
            Символическими указателями являются файлы хранящие ссылки на указатель в формате: <i>ref: refs/heads/&lt;указатель&gt;</i>.
            Все символические указатели, хранятся непосредственно в каталоге .git/.
        </p>
        <p>
            Все??? символические указатели создаются автоматически???
            Они имеют имена В ВЕРХНЕМ РЕГИСТРЕ.
            Наиболее важными символическими ссылками являются: HEAD, ORIG_HEAD и MERGE_HEAD.
        </p>
        <p>
            Символический указатель, с именем HEAD мы уже рассмотрели.
        </p>

        <h4>Ветки</h4>

        <p>
            В книге по git постоянно используется термин ветка. Однако в разных местах в этот термин вкладывается разный смысл. То это некая последовательность коммитов (не очень понятго какая), то указатель на коммит.
            Мы веткой будем называть только последовательность символов (ниже четко определим какую именно).
            Указатели ветками мы никогда называть не будем.
        </p>
        <p>
            <i>Ветка</i> - цепочка коммитов начинающаяся с некоторого указателя, идущая вниз и включающая в себя все коммит-объекты, созданные когда текущим был этот коммит. (Коммит-оъекты создаются не только командой <i>git commit</i>, но и <i>git merge</i> [коммиты слияния]).
            <br>
            Т.о. каждый указатель определяет свою ветку. Имя указателя одновременно является именем соответствующей ветки.
        </p>
        <p>
            Прежде чем создать новую ветку надо создать новый указатель, сделать его текущим.
            Коммиты созданные после этого будут относится к новой ветке.
        </p>
        <p>
            Склонируем проект project1 в папку project2
        <pre><code style="color: blue">
$ git clone project1 project2
Cloning into 'project2'...
done.

$ cd project2

$ get status
bash: get: command not found

$ git branch
* master

$ git log
commit 344b36ba2aeb489f97a4928816eeeefb30ddfac2 (HEAD -> master, origin/master, origin/HEAD)
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:03:00 2000 +0200

    comment #3

commit 03c1a7f12800978dde0b8cd6383595e7007d0098
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:02:00 2000 +0200

    comment #2

commit 69701b6e701d429882c083e98e1ecf195868b38c
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:01:00 2000 +0200

    comment #1
</code></pre>
        Указатель master у нас уже есть. Он указывает на коммит 6970.
        <pre><code style="color: blue">
$ git rev-parse master
344b36ba2aeb489f97a4928816eeeefb30ddfac2
</code></pre>
        Создадим второй указатель с именем test указывающий на коммит (03c1).
        <pre><code style="color: blue">
$ git branch test 03c1

$ git rev-parse test
03c1a7f12800978dde0b8cd6383595e7007d0098
</code></pre>
        <p>
            Переключиться на указатель &lt;branchname&gt; можно командой <i>git checkout &lt;branchname&gt;</i>.
            Давайте переключаемся на созданный указатель test, посмотрим log, затем вернемся на master и снова посмотрим log.
        </p>
        <p>
        <pre><code style="color: blue">
$ git checkout test
Switched to branch 'test'

$ git log --oneline
03c1a7f (HEAD -> test) comment #2
69701b6 comment #1

$ git checkout master
Switched to branch 'master'
Your branch is up to date with 'origin/master'.

$ git log --oneline
344b36b (HEAD -> master, origin/master, origin/HEAD) comment #3
03c1a7f (test) comment #2
69701b6 comment #1
</code></pre>
        Ветка master состоит из коммитов 344b36b -> 03c1a7f -> 69701b6, а ветка test пока пустая.
        <p>
            Текущий указатель, в выводе команды <i>git branch</i>, отмечается звездочкой (*).
        <pre><code style="color: blue">
$ git branch
* master
  test
</code></pre>

        <h3>Ветвление в git</h3>

        <p>
            стр.58-...
        </p>

        <h3>Слияние в git</h3>

        <p>
            В классическом случае операция слияния - это
            <br><br>
            1. Формирование нового дерева, которое каким-то образом включает в себя изменения, произошедшие в сливаемых ветках со времени их общего предка.
            <br><br>
            2. Формирование нового коммита с этим деревом, в качестве предков которого указаны все сливаемые коммиты
        </p>
        <p>
            Автоматическая система слияния git в многих случаях может сама "слить" ветки, без участия пользователя. Например, если изменения в сливаемых ветках затрагивают разные файлы, или один и тот же файл, но изменяемые строчки не пересекаются. Новое дерево в таком случае формируется автоматически.
        </p>
        <p>
            В общем случае новое дерево автоматически сформироваться не может из за того, что одни изменения конфликтуют с другими. *********
        </p>

        <h3>Метки</h3>

        <p>
            Метки как ссылки и метки как объекты.
        </p>
        <p>
            стр.52-56
        </p>

        <h4>Легковесные метки</h4>

        <p>
            <i>Легковесная метка(lightweight teg)</i> - файл хранящий идентификатор объекта любого типа (блоб, дерево, коммит или объект-метку).
            <br>
            Легковесную метку можно использовать в git-командах вместо идентификатора объекта.
            <br>
            Имя указателя назначается только исходя из соображений удобства запоминания человеком.
            <br>
            На имя указателя распространяются только ограничения наложенные на имена файлов.
            <br>
            Метка создается командой <i>git tag -s &lt;tagname&gt; &lt;object&gt;</i>.
            <br>
            Метки хранятся в каталоге <i>.git/refs/tags/</i>.
            <br>
            Нет штатных средств с помощью которых можно изменить идентификатор объекта на который она указывает. Будучи однажды созданной, она продолжает указывать на один и тот же объект.
        </p>

        <h4>Тяжеловесные или аннотированные теги (annotated tag)</h4>

        <p>
            <i>Тяжеловесные или аннотированные теги (annotated tag)</i> - это объект еще одного типа.
            <br>
            В тело этого объекта записываются следующие данные:
        <pre><code style="color: blue">     * идентификатор объекта, на который тот указывает.
     * Тип объекта, на который тот указывает (blob, tree, commit или tag) (да, бывают теги  указывающие на теги!)
     * Имя легковесной метки, указывающей на этот анонсированный тег, и которая создается одновременно с ним.
     * Дата и время создания тега
     * Имя и e-mail создателя тега (в таком же формате как имя автора коммита)
     * Кусок произвольных данных на усмотрение создателя тега
</code></pre>
        Объект создается командой <i>git tag -a &lt;tagname&gt; &lt;object&gt;</i>.
        <p>Вместе с анонсированной меткой создается легковесная метка указывающая на этот объект.</p>
        <p>
            В кусок произвольных данных могут быть записано сообщение тега (по смыслу аналогичное сообщению коммита), а также в него можно внедрить GPG-подпись объекта. Такой тег будет называться подписанным(tag).
        </p>
        <p>
            Вот тут и проявляется магия git - создавая подписанный тег на определенный коммит, на самом деле подписывается и сам коммит, и вся его история, и все деревья, составляющие историю, и все блобы, "висящие на ветках этих деревьев". То есть все, на что можно "дотянуться" по ссылкам от коммита.
        </p>

        <h3>Удаленные репозитории</h3>

        <p>
            Git позволяет работая в одном репозитории получать и принимать изменения из другого репозитория.
            В этом случае первый репозиторий называется <i>локальным</i>, а второй - <i>удаленным</i>.
        </p>
        <p>
            Удаленный репозиторий может располагаться на том же компьютере, что и локальный, в локальной сети, или где то в интернете. Главное у пользователя должен быть доступ к нему одним из способов, который поддерживает <i>git</i>.
            Для получения изменений достаточно иметь доступ на чтение, для передачи изменений нужен доступ на запись.
        </p>
        <p>
            Вначале надо <i>подсоединить</i> удаленный репозиторий к локальному, т.е. указать указать где он находится, при помощи <i>URL</i> и присвоить ему <i>имя (shortname)</i>.
            <br>
            Подсоединение выполняется командой <i>git remote add &lt;shortname&gt; &lt;url&gt;</i>.
            <br>
            (??? Подсоединение удаленного репозитория выполняется автоматически при его клонировании (см. далее). ???)
        </p>
        <p>
            Информация о подсоединенных репозиториях хранится в локальном конфигурационном файле репозитория.
        </p>
        <p>
            Пусть у нас имеется репозиторий в текущей папке и репозиторий по пути <i>/home/Thomas/project1</i>, с которым мы хотим работать как с удаленным репозиторием. Так команда
        <pre><code>$ git remote add origin /home/Thomas/project1</code></pre>
        подсоединяет удаленный репозиторий <i>/home/Thomas/project1</i> и назначает ему имя <i>origin</i>.
        Информация об этом сохраняется в разделе [remote "origin"] локального конфигурационного файла.
        <pre><code>[remote "origin"]
	url = /home/Thomas/project1
	fetch = +refs/heads/*:refs/remotes/origin/*</code></pre>
        <p>
            Командой <i>git remote</i> без параметров можно посмотреть список всех подсоединенных удаленных репозиториев.
            <br>
            Эта же команда с параметром «-v» выводит дополнительно URL удаленных репозиториев.
        </p>
        <p>
            Например:
        <pre><code>$ git remote
origin

$ git remote -v
origin	/home/Thomas/project1 (fetch)
origin	/home/Thomas/project1 (push)</code></pre>
        <p>
            Команда <i>git remote add</i> с дополнительными параметрами может установить разные URL для чтения (fetch) и записи (push).
        </p>

        <h3>Работа с удаленными репозиториями по сети</h3>

        <p>
            Git работает с удаленными репозиториями по локальным сетям точно также, как с репозиториями на вашем компьютере.
            У вас должна быть права на чтение и запись в папку .git репозитория.
            Кроме того работать с удаленными репозиториями можно по протоколам: HTTP/HTTPS, SSH (Secure Shell) и Git.
            Сетевого протокола протокол выбирается на основании URL.
        </p>
        <p>
            URL (Uniform Resource Locator, унифицированный указатель ресурса) — система унифицированных адресов электронных ресурсов, или единообразный определитель местонахождения ресурса (например файла).
        </p>
        <p>
            Структура URL:
            <br>
            <i>&lt;схема&gt;</i>:[//[<i>&lt;логин&gt;</i>[:<i>&lt;пароль&gt;</i>]@]<i>&lt;хост&gt;</i>[:<i>&lt;порт&gt;</i>]][/<i>&lt;URL-путь&gt;</i>]
            <br>
            где:
            <br>
            <i>схема</i> - схема обращения к ресурсу; в большинстве случаев имеется в виду сетевой протокол
            <br>
            <i>логин</i> - имя пользователя, используемое для доступа к ресурсу
            <br>
            <i>пароль</i> - пароль указанного пользователя
            <br>
            <i>хост</i> - полностью прописанное доменное имя хоста в системе DNS или IP-адрес хоста в форме четырёх групп десятичных чисел, <br>
            разделённых точками; числа — целые в интервале от 0 до 255.
            <br>
            <i>порт</i> - порт хоста для подключения
            <br>
            <i>URL-путь</i> - уточняющая информация о месте нахождения ресурса; зависит от протокола.
        </p>

        <h3>Голые репозитории</h3>

        <p>
            Помимо <i>обычных</i> репозиториев, с которыми мы до сих пор имели дело, бывают т.н. <i>голые (чистые, bare)</i> репозитории.
            Голые репозитории не имеют своего рабочего каталога.
            Они используются только в качестве удаленных репозиториев для обмена изменениями между обычными репозиториями.
        </p>
        <p>
            Такие репозитории создаются командой <i>git init</i> с параметром <i>--bare</i>.
            Имя каталога голого репозитория указывается при создании и может быть любым, но принято чтобы оно заканчивалось на «.git».
        <pre><code>
$ git init --bare test.git -b master
</code></pre>

        <h3>Создание клонов репозитория. Команда <i>git clone</i></h3>

        <p>
            Существующий репозиторий можно склонировать командой <i>git clone</i>.
            Тип клонируемого репозитория может быть любым - обычным или голым.
            Тип у клона может не совпадать с исходным.
            Голый репозиторий создается командой <i>git clone</i> с опцией <i>--bare</i>, по умолчанию - обычный репозиторий.
        </p>
        <p>
            При клонировании репозитория происходит почти точное копирование существующего репозитория (чем отличаются см. ...).
            Если клон является обычным репозиторием, то клонируемый репозиторий подсоединяется к клону как удаленный, с именем «origin».
        </p>
        <p>
            При клонировании копируется указатель текущей ветки и он становится указателем текущей веткой репозитория-клона.
            Автоматически эта ветка становится отслеживающей соответствующую удаленную ветку (что это значит см. долее).
        </p>
        <p>
            Обычно репозитории клонируют с текущей веткой <i>master</i>.
        </p>
        <p>
        <pre><code>$ git clone /home/Thomas/project1 pr1_c

$ cd pr1_c

$ git remote
origin

$ git remote -v
origin	/home/Thomas/project1 (fetch)
origin	/home/Thomas/project1 (push)</code></pre>

        <h3>Получение изменений из удаленного репозитория. Команда <i>git fetch</i></h3>

        <p>
            Команда <i>git fetch</i> загрузит с сервера все изменения, которых у вас еще нет.
            <br>
            Все новые объекты загружаются в локальную базу объектов <i>.git/objects</i>.
            <br>
            Каталог <i>.git/refs/remotes/&lt;имя_удаленного_репозитория&gt;</i> приводится в соответствие с каталогом <i>.git/refs/</i> удаленного репозитория. ????*************
        </p>
        <p>
            Указатели удаленного репозитория сокращенно называются <i>удаленными указателями</i>.
            Их имена, в локальном репозитории, состоят из имени удаленного репозитория и имени, которое они имеют в удаленном репозитории, разделенных косой чертой.
            Например указатель <i>master</i> удаленного репозитория <i>origin</i> в локальном репозитории имеет имя <i>origin/master</i>.
        </p>
        <p>
            Обратите внимание на то, что локальные и удаленные указатели ведут себя по разному.
            Если локальные указатели двигаются когда мы делаем коммиты в локальном репозитории, то удаленные указатели двигаются, когда мы получаем изменения из удаленного репозитория.
        </p>
        <p>
            Команда <i>git fetch</i> не меняет содержимого вашего рабочего каталога!
        </p>
        <p>
            После получения изменений из удаленного репозитория можно выполнить слияние командой <i>git merge</i> и
            привести файлы вашего рабочего каталога в соответствие с полученными изменениями.
        </p>

        <p>
            Получим обновлений из удаленного репозитория <i>origin</i>. Для этого выполним команду
        <pre><code>$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -&gt; origin/serverfix</code></pre>
        Вывод команды показывает, что из удаленного репозитория мы получили 7 новых (для нас) объектов и новый (для нас) указатель <i>serverfix</i>, ставший у нас удалённым указатель <i>origin/serverfix</i>.
        При этом локальный указатель на ветку <i>serverfix</i> создан не был!
        <p>
            Все удаленные указатели можно посмотреть командой <i>git branch</i> с опцией <i>-r</i>
        <pre><code>$ git branch -r
  origin/master
  origin/serverfix</code></pre>
        <p>
            Вы можите временно переключится на удаленную ветку, чтобы посмотреть новые файлы рабочего каталога (работать в удаленной ветке не получиться)
        <pre><code>$ git checkout origin/serverfix</code></pre>
        или слить удаленную ветку со своей текущей веткой
        <pre><code>git merge origin/serverfix</code></pre>

        <h3>Отслеживание веток</h3>

        <p>
            Чуть позже мы будем изучать команды работающие с удаленными репозиториями и использующие т.н. <i>отслеживаемые ветки (upstream branches)</i>.
            Отслеживаемая ветка - это ветка удаленного репозитория, которая определенным образом связана с локальной веткой.
            Отслеживаемых веток может быть сколько угодно и они могут быть из разных удаленных репозиториев.
        </p>
        <p>
            Создать локальную ветку, с тем же идентификатором как у удаленной ветки, и одновременно сделать, чтобы она отслеживала эту удаленную ветку, можно командой <i>git branch &lt;ветка1&gt; &lt;удалённый_репозиторирий&gt;/&lt;ветка2&gt;</i>.
        </p>
        <p>
            Например команда
        <pre><code>$ git branch fix origin/serverfix
Branch 'fix' set up to track remote branch 'serverfix' from origin.</code></pre>
        создает ветку <i>fix</i> и назначает ей ветку <i>origin/serverfix</i> как отслеживаемую.
        После создания указателя <i>fix</i>, он указывают на тот же коммит, что и указатель <i>origin/serverfix</i>.
        <pre><code>$ git rev-parse origin/serverfix
28b529332be1d8bc8110bec50774d92d2e5d8f05

$ git rev-parse fix
28b529332be1d8bc8110bec50774d92d2e5d8f05</code></pre>
        <p>
            Информация о том какие локальные ветки отслеживают удаленные ветки, хранится в локальном конфигурационном файле.
            Так команда из предыдущего примера добавит в локальный конфигурационный файл такой раздел
        <pre><code>[branch "fix"]
	remote = origin
	merge = refs/heads/serverfix</code></pre>
        <p>
            Сделать так, чтобы текущая ветку отслеживала нужную удаленную ветку можно командой <i>git branch</i> с ключом <i>-u</i> или <i>--set-upstream-to</i>.
            <br>
            Формат команды: <i>git branch -u &lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;</i>.
            <br>
            Той же командой можно переназначать отслеживаемые ветки.
        </p>
        <p>
            Создать новую локальную ветку с идентификатором удаленной ветки, назначит вторую отслеживаемой и сразу же переключиться на созданную ветку, можно командой <i>git checkout --track &lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;</i>.
            <br>
            Эта команда создает локальную ветку с именем как у удаленной ветки.
            <br>
            При этом созданная ветка, будет отслеживать указанную удаленную ветку.
        <pre><code>$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'</code></pre>
        <p>
            Команда <i>git checkout -b &lt;ветка1&gt; &lt;удалённый_репозиторирий&gt;/&lt;ветка2&gt;</i> работает как и предыдущая, но создает локальную ветку с именем, отличным от имени удалённой ветки. Например:
        <pre><code>$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'</code></pre>
        Теперь ваша локальная ветка <i>sf</i> будет отслеживать удаленную ветку <i>origin/serverfix</i>.
        <p>
            Посмотреть список всех локальных веток, с информацией о том у каких веток есть отслеживаемые ветки, и на сколько коммитов локальные ветки опережают отслеживаемые или отстают от них, можно командой <i>git branch</i> с опцией <i>-vv</i>.
            Пример вывода:
        <pre><code>$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new</code></pre>
        <p>
            Вывод команды показывает, что:
            <br>
            - ветка <i>iss53</i> отслеживает ветку <i>origin/iss53</i> и что локальная ветка опережает на два изменения, т.е. мы имеем два локальных коммита, которые не отправлены на сервер.
            <br>
            - ветка <i>master</i> отслеживает ветку <i>origin/master</i> и что локальная ветка в актуальном состоянии.
            <br>
            - ветка <i>serverfix</i> отслеживает ветку <i>server-fix-good/teamone</i> и что локальная ветка опережает на три коммита и отстает на один, т.е. есть один коммит на сервере, который мы еще не слили с веткой <i>serverfix</i> и три локальных коммита, которые вы еще не отправили.
            <br>
            - ветка <i>testing</i> не отслеживает удаленную ветку.
        </p>
        <p>
            Эта команда не обращается к серверам.
            Данные об отставании или опережении основана на информации, которая получена при последнем подключении к удаленным репозиториям.
            Если вы хотите полностью быть в курсе опережающих и отстающих коммитов, вам необходимо извлечь данные из всех ваших удаленных репозиториев перед запуском этой команды. Например так:
        <pre><code>$ git fetch --all; git branch -vv</code></pre>
        <p>
            Если локальная ветка отслеживает ветку <i>&lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;</i>, то в команде <i>git</i> ссылаться на эту отслеживаемую ветку можно с помощью конструкции <i>@{upstream}</i> или, что тоже самое <i>@{u}</i>.
            <br>Так, если вы находитесь на ветке <i>master</i>, которая отслеживает <i>origin/master</i>, то вместо <i>git merge origin/master</i> вы можите написать <i>git merge @{u}</i>.
        </p>

        <h3>Команда <i>git pull</i></h3>

        <p>
            Команда <i>git pull</i>, по существу является эквивалентом двух последовательно выполняемых команд <i>git fetch</i> и <i>git merge</i>.
            <br>
            Так команда <i>git pull &lt;удалённый_репозиторирий&gt;</i> сначала получить все изменения с <i>&lt;удалённый_репозиторирий&gt;</i>, проделав тоже, что и <i>git fetch &lt;удалённый_репозиторирий&gt;</i>, а затем сольет текущую ветку с соответствующей отслеживаемой удаленной веткой.
            <br>
            Если у текущей ветки есть отслеживаемая удаленная ветка &lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;, то она сольется с текущей, как по команде <i>git merge &lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;</i>.
            <br>
            Если текущая ветка не отслеживает никакую удаленную, то операция слияния не выполняется.
        </p>
        <p>
            Если находясь на ветке, у которой есть отслеживаемая удаленная ветка, вы наберёте <i>git pull</i> или <i>git pull</i> без указания удаленного репозитория, команда получит изменения из репозитория, имя которого входит в имя отслеживаемой удалённой ветки.
            Например если текущей веткой является ветка <i>master</i> и она отслеживает ветку <i>origin/master</i>, то изменения будут получены с репозитория <i>origin</i>.
        </p>
        <p>
            Магия <i>git pull</i> может часто сбивать с толку, поэтому обычно лучше явно использовать команды <i>git fetch</i> и <i>git merge</i>.
        </p>

        <h3>Отправка изменений в удаленный репозиторий. Команда <i>git push</i></h3>

        <p>
            Когда вы хотите поделиться своими наработками с другими, вам необходимо отправить (push) изменения в удаленный репозиторий, к которому у вас есть доступ на запись.
            <br>
            Не все ваши локальные ветки будут синхронизируются с удалёнными репозиториями.
            Вам нужно явно указать ветки, которыми вы хотите поделиться.
            Т.о вы можете отправлять только те тематические ветки, над которыми вы работаете совместно с другими,
            и не отправлять другие ветки, которые вы не хотите показывать.
        </p>

        <p>
            Формат команды: <i>git push &lt;имя_удаленного_репозитория&gt; &lt;имя_лок_ветки&gt;:&lt;имя_удал_ветки&gt;</i>
            <br>
            Можно использовать этот формат для отправки локальной ветки в удалённую ветку с другим именем.
            <br>
            Когда имя ветки в локальном и удаленном репозитории совпадают, формат команда можно упростить:
            <i>git push &lt;имя_удаленного_репозитория&gt; &lt;имя_ветки&gt;</i>
        </p>
        <p>
            Например:
        <pre><code>$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -&gt; serverfix</code></pre>
        <p>
            Если команду <i>git push</i> выполнить без параметров, то будут отправлены изменения текущей ветки, но только если у неё есть отслеживаемая удаленная ветка.
            Команда отправит изменения в тот репозиторий, имя которого входит в имя отслеживаемой удалённой ветки.
            Например если текущей веткой является ветка <i>master</i> и она отслеживает ветку <i>origin/master</i>, то изменения будут отправлены в репозиторий <i>origin</i>.
        </p>
        <p>
            Когда обычные (не голые) репозитории подсоединяются в качестве удаленных в отношении них есть такое ограничение -
            обновлять текущую ветку в удаленном репозитории запрещено.
            <br>
            Это сделало бы состояние индекса и рабочего каталога противоречивым.
            <br>
            Вам прийдется выполнить «git reset --hard», чтобы состояние рабочего каталога снова соответствовало HEAD.
        <p></p>
        Такова настройка git по умолчанию.
        Однако вы можете установить значение опции «receive.denyCurrentBranch» в «ignore» или «warn» во внешнем репозитории,
        чтобы разрешить отправку в его текущую ветку; но это не рекомендуется, если только вы не намерены обновить его
        рабочий каталог способом подобным
        вышеописанному.

        <h3>Удаление веток в удалённом репозитории</h3>

        <p>
            Скажем, вы и ваши соавторы закончили с нововведением и слили его в ветку <i>master</i> в удалённом репозитории (или в какую-то другую ветку, где хранится стабильный код).
            Вы можете удалить ветку в удалённом репозитории, используя команду <i>git push</i> с опцией <i>--delete</i>.
            Если вы хотите удалить ветку <i>serverfix</i> в репозитории <i>origin</i>, выполните следующее:
        <pre><code>$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix</code></pre>
        <p>
            Команда удаляет только указатель на ветку в удаленном репозитории, коммиты этой ветки она не трогает.
            Коммиты удаленных веток (и другие недоступные объекты) периодически??? удаляет сборщик мусора.
            Если ветка была удалена случайно, чаще всего ее легко восстановить.
        </p>

        <h3>Удаление и переименование удалённых репозиториев</h3>

        <p>
            стр. 51
        </p>

        <h3>Псевдонимы git</h3>

        <p>
            стр. 56-57
        </p>


        <h3>Github в качестве удаленного репозитория</h3>
        <p>
            ******************
        </p>

        <h4>Копирование репозитория с другого компьютера</h4>

        <p>
            Если на каком то компьютере у вас уже есть репозиторий Git, то чтобы скопировать его на другой компьютер достаточно:
            <br>
            1) из существующего репозитория скопировать в пустой каталог второго компьютера только каталог <i>.git/</i>;
            <br>
            2) восстановить рабочие файлы и каталоги командой:
        <pre><code style="color: blue">   $ git checkout HEAD .
</code></pre>
        или
        <pre><code style="color: blue">   $ git checkout .
</code></pre>
        или
        <pre><code style="color: blue">   $ git reset --hard HEAD
</code></pre>

        <h4>Клонирование существующего репозитория с github</h4>

        <p>Клонирование репозитория с github осуществляется командой git clone [url].
            <br>
            После клонирования репозитория автоматически производится и восстановление файлов рабочего каталога???
            <br>
            Например, если вы хотите клонировать репозиторий konstant-in/example1. Вы можете сделать это следующим образом:

        <pre><code style="color: blue">   $ git clone https://github.com/konstant-in/example1.git
</code></pre>

        <p>Эта команда создаёт директорию “libgit2”, инициализирует в ней поддиректорию .git, скачивает все данные для этого репозитория и создаёт (checks out) рабочую копию последней версии. Если вы зайдёте в новую директорию libgit2, то увидите в ней файлы проекта, готовые для работы или использования. Для того, чтобы клонировать репозиторий в директорию с именем, отличающимся от “libgit2”, необходимо указать желаемое имя, как параметр командной строки:
        <pre><code style="color: blue">   $ git clone https://github.com/konstant-in/example1.git my_example1</code></pre>
        Эта команда делает всё то же самое, что и предыдущая, только результирующий каталог будет назван my_example1.
        <p>
            Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый
            репозиторий под именем «origin».
        </p>


        <h4>Восстановление состояния рабочего каталога. Команда git checkout *******************</h4>

        <p>
            Имея в распоряжении слепки системы, можно восстановить отдельные файлы или всю иерархию файлов и подкаталогов рабочего каталога.
        </p>
        <p>
            Ни одна из команд восстановления не затрагивают базу объектов репозитория. Её состояние всегда остается без изменения.
        </p>
        <p>
            Для этого можно воспользоваться командой:
        <pre><code style="color: blue">
   git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​
</code></pre>
        &lt;pathspec&gt; - один файл, список файлов (разделенных пробелами), * (звездочка) или . (точка).
        <br>
        Чем * (звездочка) отличается от . (точка)???????????
        <br>
        <br>
        Overwrite paths in the working tree by replacing with the contents in the index or in the &lt;tree-ish&gt; (most often a commit). When a &lt;tree-ish&gt; is given, the paths that match the &lt;pathspec&gt; are updated both in the index and in the working tree.
        <br>
        <br>
        Когда не задан &lt;tree-ish&gt;, то пути, соответствующие &lt;pathspec&gt;, обновляются в рабочем каталоге содержимым из индекса.
        <br>
        Когда &lt;tree-ish&gt; задан, то пути, соответствующие &lt;pathspec&gt;, обновляются содержимым из &lt;tree-ish&gt; как в индексе, так и в рабочем каталоге.
        <br>
        <br>
        The index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using -f will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using --ours or --theirs. With -m, changes made to the working tree file can be discarded to re-create the original conflicted merge result.
        <br>
        <br>
        Индекс может содержать не объединенные записи из-за предыдущего неудачного слияния. По умолчанию, если вы
        попытаетесь извлечь такую запись из индекса, операция извлечения завершится неудачей и ничего не будет извлечено.
        Использование -f будет игнорировать эти необработанные записи. Содержимое с определенной стороны слияния можно
        извлечь из индекса с помощью --ours или --theirs. С помощью -m изменения, внесенные в файл рабочего дерева, можно
        отменить, чтобы заново создать исходный конфликтующий результат слияния.

        <h5>Пример восстановление</h5>

        <p>Удалим все файла в рабочем каталоге из прошлого примера. Затем восстановим содержимое по первому слепку.</p>

        <p>*********</p>

        <p>Второй раз удалим все файла в рабочем каталоге и восстановим содержимое по второму слепку.</p>

        <p>*********</p>


        <p>
            **************^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^***********************
        </p>

        <h2>В ЗАКЛЮЧЕНИИ (Delta-сжатие)</h2>

        <p>
            До вызова git-repack (или включающего его git gc) блобы хранятся отдельно, но каждый объект (блоб, дерево, коммит, тег) хранится в сжатом виде (сжатие zlib).
        </p>
        <p>
            Delta-сжатие появляется после вызова git repack или git gc. Во время этого процесса все неупакованные объекты объединяются в .pack - файлы, где помимо обычного сжатия, применяется еще дельта-сжатие.
        </p>
        <p>
            У дельта-сжатия два параметра - окно (window) и глубина (depth).
            Чтобы применить дельта-сжатие, git pack-objects (вызываемый из git repack) сравнивает куски объектов, применяет к ним дельта-сжатие (то есть образно говоря дифф) и смотрит, получилось ли сэкономить на дельта-сжатии место. Если получилось - то в архив кладется первый объект и дифф до второго. При этом также используется сортировка по типу (вряд ли блоб будет давать хорошую дельту относительно коммита или дерева), затем по размеру (и опционально по имени объекта). Получается список объектов. Для каждого объекта в этом списке проверяются на "дельта-совместимость" ближайшие в списке объекты, находящиеся в рамках "окна" (window). По умолчанию на совместимость проверяется 10 объектов, но этот параметр можно увеличить. По результатам проверки выбирается объект с минимальной дельтой (это может быть в принципе объект, который также является дельтой третьего объекта - в таком случае говорят, что тут глубина дельты равна 2).
        </p>
        <p>
            Также по умолчанию глубина дельта-сжатия - 50, то есть ориентировочно 50 версий одного и того же файла хранятся в виде дельт относительно друг друга, а пятьдесят первая - в виде полной версии файла. Далее следующие 50 версий этого файла будут опять в виде дельт. Это нужно для ускорения получения блобов - иначе при допустим 1000 изменениях в одном файле последнюю версию надо будет получать, доставая первую и применяя к ней 1000 дельт, а это долго. 50 дельт считается разумным умолчанием. В этом случае достается 950-ая версия и к ней применяется 50 дельт, что в 20 раз быстрее.
        </p>
        <p>
            Варьируя параметры --window и --depth у git repack, можно находить подходящий компромисс между временем упаковки и распаковки объекта и занимаемым им местом. При этом параметр --window напрямую влияет на время упаковки (работы git repack), а --depth - на среднее время распаковки объекта.
        </p>
        <p>
            То есть, в норме - получается, сыпем при работе в папку .git файлики-объекты, и время от времени (когда захочется) вызываем упаковку насыпанного в очередной .pack?
        </p>
        <p>
            А git тем временем продолжает прозрачно (только чуть медленнее) работать как с россыпью новых файликов, так и с этими пакетами, как будто все файлики по-прежнему рассыпаны, и вовсе не упаковывались?
        </p>
        <p>
            Да, именно так. Плюс при передаче данных по сети (git push, git pull) тоже передаются пакеты, а не отдельные файлы.
        </p>

    </div>
</BODY>

</HTML>
